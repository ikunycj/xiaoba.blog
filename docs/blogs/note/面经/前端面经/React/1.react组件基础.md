
## 1. React 事件机制

**React 事件机制**主要基于一个称为 **SyntheticEvent**（合成事件）的系统来统一不同浏览器上的事件表现，同时使用事件**委托**（event delegation）机制来提升性能。

以下将从几个方面为你详细介绍 React 事件机制的核心原理与常见用法。

---

### 1. React 中事件机制的特点

1. **合成事件（SyntheticEvent）**
    - React 并不直接将原生 DOM 事件对象暴露给你，而是使用一个名为 `SyntheticEvent` 的事件包装器。
    - 该合成事件可以保证在不同浏览器环境下有一致的事件属性和方法，比如 `target`, `type`, `pageX`, `pageY` 等都被统一封装。
    - 早期版本的 React（17 以下）使用了 **事件池（Event Pooling）** 技术，每次触发事件后会将合成事件对象内容重置以复用对象，避免频繁创建和销毁对象。但从 React 17 开始已经逐渐移除了事件池，你可以随时异步访问事件对象的属性

2. **事件委托（Event Delegation）**
    - React 并不是在每个真实 DOM 节点上直接绑定事件监听器，而是采用事件委托的方式：
        - 旧的实现（React < 17）通常将所有事件统一绑定到 `document` 或 `window` 上；
        - React 17+ 将事件监听器绑定到**React 根节点**（根容器）上。
    - 通过事件冒泡（事件从子元素冒泡到父元素）来捕获事件，再由 React 的内部机制去分发给对应的组件。
    - 这种机制可以减少大量事件监听器的注册，提升性能。
3. **跨浏览器一致性**

    - 由于使用了 SyntheticEvent，React 的事件在各种浏览器中都有相同的属性和行为，你无需针对不同浏览器做不同的兼容处理。
4. **在 JSX 中使用 CamelCase 命名**
    
    - React 事件的命名方式与原生 DOM 事件的不同之处在于需要使用“驼峰命名”，如 `onClick`、`onChange`、`onMouseOver` 等，而原生 DOM 中往往是 `onclick`、`onchange`、`onmouseover` 等小写形式


---

### 2. React 事件绑定示例

在 JSX 中，你可以直接在组件的元素上使用事件属性来绑定事件处理函数。例如：

```jsx
function App() {
  function handleClick(event) {
    // event 是一个合成事件对象 (SyntheticEvent)
    console.log('按钮被点击了');
    // 阻止默认行为
    event.preventDefault();
    // 阻止事件冒泡
    event.stopPropagation();
  }

  return (
    <button onClick={handleClick}>
      点击我
    </button>
  );
}
```

#### 事件处理与状态更新

React 里通常会将事件和 `setState`/`useState` 状态更新结合使用，来实现页面交互。例如：

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);

  function handleIncrement() {
    setCount(count + 1);
  }

  return (
    <div>
      <p>当前计数：{count}</p>
      <button onClick={handleIncrement}>+1</button>
    </div>
  );
}

export default Counter;
```

---

### 3. 事件传播与冒泡/捕获

#### 3.1 冒泡阶段

在默认情况下，当一个子元素触发事件后，事件会沿着 DOM 树逐级向上直到根节点或被手动阻止为止，这个过程称为**事件冒泡**。

在 React 中，你也可以使用合成事件对象的 `event.stopPropagation()` 来阻止事件向父级冒泡。

#### 3.2 捕获阶段

React 也支持事件捕获阶段，但需要在事件名后加上 `Capture` 关键字。例如：

```jsx
<div onClickCapture={handleCapture}>...</div>
```

在捕获阶段注册的回调会比冒泡阶段更先触发。

---

### 4. React 17+ 与事件绑定变化

在 **React 17+** 中，React 改变了事件的委托方式：

- **React 17 之前**：默认把所有事件监听器绑定到 `document` 上。
- **React 17 及之后**：把事件监听器绑定到**根容器**（通常是 `ReactDOM.render` 目标节点）上。

对大部分使用者而言，这种变化在使用层面影响不大，但如果你在外部
这样做的好处是方便**多版本 React** 或**多个 React 应用**共存，以及在与非 React 应用融合时更容易管理事件，不会出现事件冲突。
通过 `document.addEventListener` 监听或阻止事件，可能会影响到 React 组件内部的事件流，需要酌情处理。

---

### 5. 常见事件类型

React 对常见的事件类型都提供了支持，常见的一些分类如下：

1. **鼠标事件**
    - `onClick`, `onDoubleClick`, `onMouseDown`, `onMouseMove`, `onMouseUp`, `onMouseEnter`, `onMouseLeave`, `onContextMenu` 等。
2. **键盘事件**
    - `onKeyDown`, `onKeyPress`, `onKeyUp` 等。
3. **表单事件**
    - `onChange`, `onInput`, `onSubmit`, `onFocus`, `onBlur` 等。
4. **焦点事件**
    - `onFocus`, `onBlur` 等。
5. **拖拽事件**
    - `onDrag`, `onDragStart`, `onDragOver`, `onDrop` 等。
6. **触摸事件（移动端）**
    - `onTouchStart`, `onTouchMove`, `onTouchEnd` 等。

对于每种事件，React 都提供了一个合成事件对象，拥有通用的事件属性和方法。

---

### 6. 防止默认行为和事件冒泡

在原生 DOM 中，你可以使用 `event.preventDefault()` 来阻止默认行为，比如点击链接时阻止跳转；用 `event.stopPropagation()` 来阻止事件冒泡。在 React 的合成事件中也可以这么使用：

```jsx
function LinkButton() {
  function handleClick(e) {
    e.preventDefault(); // 阻止默认跳转
    console.log('阻止了默认链接跳转行为');
  }

  return (
    <a href="https://example.com" onClick={handleClick}>
      点击尝试跳转
    </a>
  );
}
```

---

### 7. 事件处理函数的绑定方式

1. **内联声明**
  ```jsx
  <button onClick={() => console.log('Clicked!')}>点击</button>
  ```
- 直接使用箭头函数，简洁方便，但如果过多使用会在每次渲染时创建新的函数对象，可能在一些场景下引发性能或子组件重复渲染问题（可配合 `memo` 或者父组件中的函数绑定来优化）。

2. **绑定到组件实例方法**
```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this); // 构造函数中绑定
  }

  handleClick() {
    console.log('class-based click');
  }

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```
 - 传统 class 组件写法，需要在构造函数中手动 `.bind(this)`。
 
3. **使用类的公共字段语法**（class fields）
```jsx
class MyComponent extends React.Component {
  handleClick = () => {
    console.log('public class field');
  };

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```
- 这种写法可以避免在构造函数中绑定 `this`，语法更简洁，但需要 `Babel` 或较新的环境支持。

4. **函数式组件（Hook）**
    ```jsx
    function MyButton() {
      const handleClick = () => {
        console.log('function component click');
      };
    
      return <button onClick={handleClick}>点击</button>;
    }
    ```
- 在函数式组件中，事件处理函数就是一个闭包，搭配 Hooks 可使用组件内的状态、上下文等信息。

---

### 8. 事件与状态的异步更新

React 的状态更新（`setState`/`useState`）是**异步批量处理**的，这意味着在事件回调里多次更新状态，可能不会立刻生效，需要等到本次事件回合结束后再统一执行更新并重新渲染。因此，你往往需要使用回调形式的更新函数来确保使用最新的 state：

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  function handleMultipleUpdates() {
    // 连续多次使用旧状态会造成问题，所以要使用回调函数
    setCount((prevCount) => prevCount + 1);
    setCount((prevCount) => prevCount + 1);
  }

  return (
    <div>
      <p>当前计数：{count}</p>
      <button onClick={handleMultipleUpdates}>加2</button>
    </div>
  );
}
```

---

### 9. 小结

1. **合成事件**：React 使用 `SyntheticEvent` 封装了浏览器原生事件，实现了跨浏览器一致性，并提供了类似 DOM 事件的属性和方法。
2. **事件委托**：React 利用事件冒泡在根容器统一处理事件监听，减少 DOM 上的事件绑定数量并提升性能。
3. **事件绑定**：在 JSX 中使用 `onClick`、`onChange` 等属性结合函数式或 class 组件进行事件处理。
4. **阻止默认与冒泡**：依旧使用 `event.preventDefault()` 和 `event.stopPropagation()`。
5. **React 17+ 的变化**：主要是将委托事件的绑定位置改为 React 应用的根容器，以便多应用、不同 React 版本共存。
6. **异步状态更新**：在事件处理函数内更新状态时，需注意 React 的状态是批量异步更新，需要使用正确的方式（如回调形式）来获取最新 state。

正确理解和使用 React 事件系统，可以帮助你在开发中更好地处理交互逻辑，写出性能高、可维护性好的前端代码。

## 2. React的事件和普通的HTML事件有什么不同？

区别：

- **名称命名方式**，原生事件为全小写，react 事件采用小驼峰；
- **函数处理语法**，原生事件为字符串，react 事件为函数；
- react 事件不能采用 `return false` 的方式来阻止浏览器的默认行为，而必须要地明确地调用`preventDefault()`来阻止默认行为。

合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象，其优点如下：

- 兼容所有浏览器，更好的跨平台；
- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。
- 方便 react 统一管理和事务机制。

事件的执行顺序为**原生事件先执行，合成事件后执行**，合成事件会冒泡绑定到 `document` 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，`因为需要冒泡到document` 上合成事件才会执行。

## 3. React 组件中怎么做事件代理？它的原理是什么？

React基于Virtual DOM实现了一个`SyntheticEvent`层（合成事件层），定义的事件处理器会接收到一个合成事件对象的实例，它符合W3C标准，且与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。

在React底层，主要对合成事件做了两件事：

- **事件委派：** React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。
- **自动绑定：** React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。

## 4. React 高阶组件、Render props、hooks 有什么区别，为什么要不断迭代

这三者是目前react解决代码复用的主要方式：

- 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。具体而言，高阶组件是参数为组件，返回值为新组件的函数。
- render props是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术，更具体的说，render prop 是一个用于告知组件需要渲染什么内容的函数 prop。
- 通常，render props 和高阶组件只渲染一个子节点。让 Hook 来服务这个使用场景更加简单。这两种模式仍有用武之地，（例如，一个虚拟滚动条组件或许会有一个 renderltem 属性，或是一个可见的容器组件或许会有它自己的 DOM 结构）。但在大部分场景下，Hook 足够了，并且能够帮助减少嵌套。

**（1）HOC** 官方解释∶

> 高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

简言之，HOC是一种组件的设计模式，HOC接受一个组件和额外的参数（如果需要），返回一个新的组件。HOC 是纯函数，没有副作用。
```js
// hoc的定义
function withSubscription(WrappedComponent, selectData) {
  return class extends React.Component {
    constructor(props) {
      super(props);
      this.state = {
        data: selectData(DataSource, props)
      };
    }
    // 一些通用的逻辑处理
    render() {
      // ... 并使用新数据渲染被包装的组件!
      return <WrappedComponent data={this.state.data} {...this.props} />;
    }
  };

// 使用
const BlogPostWithSubscription = withSubscription(BlogPost,
  (DataSource, props) => DataSource.getBlogPost(props.id));
```

HOC的优缺点∶

- 优点∶ 逻辑复用、不影响被包裹组件的内部逻辑。
- 缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖

**（2）Render props** 官方解释∶

> "render prop"是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术

具有render prop 的组件接受一个返回React元素的函数，将render的渲染逻辑注入到组件内部。在这里，"render"的命名可以是任何其他有效的标识符。

```js
// DataProvider组件内部的渲染逻辑如下
class DataProvider extends React.Components {
     state = {
    name: 'Tom'
  }

    render() {
    return (
        <div>
          <p>共享数据组件自己内部的渲染逻辑</p>
          { this.props.render(this.state) }
      </div>
    );
  }
}

// 调用方式
<DataProvider render={data => (
  <h1>Hello {data.name}</h1>
)}/>
```

由此可以看到，render props的优缺点也很明显∶

- 优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者。
- 缺点：无法在 return 语句外访问数据、嵌套写法不够优雅

**（3）Hooks** 官方解释∶

> Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。

```js
// 自定义一个获取订阅数据的hook
function useSubscription() {
  const data = DataSource.getComments();
  return [data];
}
// 
function CommentList(props) {
  const {data} = props;
  const [subData] = useSubscription();
    ...
}
// 使用
<CommentList data='hello' />
```

以上可以看出，hook解决了hoc的prop覆盖的问题，同时使用的方式解决了render props的嵌套地狱的问题。hook的优点如下∶

- 使用直观；
- 解决hoc的prop 重名问题；
- 解决render props 因共享数据 而出现嵌套地狱的问题；
- 能在return之外使用数据的问题。

需要注意的是：hook只能在组件顶层使用，不可在分支语句中使用。

**总结∶** Hoc、render props和hook都是为了解决代码复用的问题，但是hoc和render props都有特定的使用场景和明显的缺点。hook是react16.8更新的新的API，让组件逻辑复用更简洁明了，同时也解决了hoc和render props的一些缺点。

## 5. 对React-Fiber的理解，它解决了什么问题？

React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程期间， React 会占据浏览器资源，这会导致用户触发的事件得不到响应，并且会导致掉帧，**导致用户感觉到卡顿**。

为了给用户制造一种应用很快的“假象”，不能让一个任务长期霸占着资源。 可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。

所以 React 通过Fiber 架构，让这个执行过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:

- 分批延时对DOM进行操作，避免一次性操作大量 DOM 节点，可以得到更好的用户体验；
- 给浏览器一点喘息的机会，它会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。

**核心思想:** Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。

## 6. React.Component 和 React.PureComponent 的区别
**React.Component** 与 **React.PureComponent** 的主要区别在于是否实现了**浅层比较（shallow compare）** 来决定是否需要更新组件。

下面是二者的具体对比：

---

### 1. React.Component

- **基础类**：React.Component 是 React 提供的最基本的类组件基类，用于创建传统的 class 组件。
- **组件更新**：在其默认实现中，每当父组件重新渲染，或 `setState()` 更新状态时，都不会自动进行任何性能优化，都会触发 `render()`。
    - 如果想要控制组件的更新逻辑，可以手动在组件里实现 `shouldComponentUpdate(nextProps, nextState)` 方法，用以决定是否重新渲染。
- **使用场景**：
    - 当你需要灵活控制更新流程、或有更加复杂的渲染逻辑时，可以使用 React.Component 并自行实现生命周期优化。

---

### 2. React.PureComponent

- **自动浅比较**：React.PureComponent 内部自动实现了 `shouldComponentUpdate()`，会对**新旧的 props 和 state 进行浅层比较**（shallow compare）。
    - 只有当 props 或 state 中的任意一个**顶层值**有变化时，才会触发重新渲染。
    - “浅比较”意味着只比较对象是否是同一个引用，而不比较对象内部更深层次的属性。
- **性能优化**：
    - 因为自动跳过了相同引用对象场景下的重复渲染，所以在一些**数据不可变**（Immutable）场景中能够带来明显性能收益。
    - 使用不当也有风险：如果 props 或 state 是可变的深层嵌套对象，PureComponent 无法检测到内部的变化，就可能会产生“更新丢失”问题（即实际上对象内部值变了，但引用没变，也就不会触发重新渲染）。
- **使用场景**：
    - 适合纯粹展示型组件或数据结构稳定、可预期的场景（如不可变数据、浅层对象或基本类型等）。
    - 在需要深层次比较或数据不可控的场景时，需要谨慎使用。

---

### 3. 使用示例对比

#### 3.1 React.Component 示例

```jsx
class NormalComponent extends React.Component {
  // 未实现 shouldComponentUpdate，默认每次父组件重新渲染都调用 render()
  render() {
    console.log("NormalComponent render");
    return <div>普通组件</div>;
  }
}
```

#### 3.2 React.PureComponent 示例

```jsx
class PureDemo extends React.PureComponent {
  // PureComponent 内部已自动实现浅比较
  render() {
    console.log("PureDemo render");
    return <div>Pure 组件</div>;
  }
}
```

**比较逻辑**：

- 当父组件更新时，React 会先对 `this.props` 和 `nextProps`（以及 `this.state` 与 `nextState`）进行浅比较，只有在浅比较发现不相同时，PureDemo 才会执行 `render()`。

---

### 4. 何时使用 PureComponent

1. **数据不可变**：
    - 当组件的 state 或 props 都使用不可变数据结构（immutable data），每次更新都会返回新的对象引用，这时 PureComponent 的浅比较就能精准检测到差异，从而减少无谓渲染。
2. **组件纯展示**：
    - 如果组件大部分情况下只依赖简单的 props 或基本类型，PureComponent 可以减少重复渲染开销。
3. **性能瓶颈**：
    - 如果应用中存在组件渲染开销较大且会频繁渲染时，可考虑将其转换为 PureComponent，以提升性能。

---

### 5. 潜在的风险或注意事项

4. **深层对象变化**
    - 由于使用的是浅比较，如果传递给组件的 props 是一个**深层嵌套的可变对象**，即使对象内部内容被修改了，只要对象引用未变，都不会被检测到。
    - 结果可能导致 UI 不更新或产生逻辑错误。
5. **无效渲染减少**
    - 如果组件本身更新代价不大，使用 PureComponent 带来的收益可能并不明显，甚至会损耗一些因为浅比较而带来的性能开销（通常这一开销比较小，但在低端设备或者极频繁的场景中也需考虑）。
6. **过早优化**
    - 只有在遇到明显的性能瓶颈，或需求场景适合时，才应该考虑 PureComponent。切记过度优化会增加代码复杂度。

---

### 6. 小结

- **React.Component**：没有自动的性能优化，需要手动编写 `shouldComponentUpdate` 或其他方法来控制渲染过程。
- **React.PureComponent**：内置浅比较逻辑，适合不可变数据或较为简单的场景，可在无需额外编码的情况下减少不必要的渲染，从而提升性能。

选择使用 **React.Component** 还是 **React.PureComponent**，主要取决于数据是否**不可变**、是否有**深层对象**，以及是否**确实需要**这层优化。根据应用情况灵活选择即可。
## 7. Component, Element, Instance 之间有什么区别和联系？

在 React 中，**Component**、**Element** 和 **Instance** 是三个既相互关联又有明确分工的概念。它们主要对应 React 内部从定义到创建，再到渲染（以及重新渲染）的不同阶段或不同抽象。下面详细介绍它们的区别和联系。

---

### 1. Component（组件）

- **定义/描述**

    - **React 组件**可以是一个 **函数组件（Function Component）**，也可以是一个 **类组件（Class Component）**。
    - 组件定义了**渲染逻辑**以及 **UI 的结构和交互**，本质上是一个**可复用的代码单元**。
- **工作方式**

1. **函数组件**：就是一个返回 React 元素（或其他组件）的函数：

```jsx
function MyButton(props) {
  return <button>{props.label}</button>;
}
```

1. **类组件**：本质是继承自 `React.Component` 或 `React.PureComponent` 的一个类，需要实现 `render()` 方法：

```jsx
class MyButton extends React.Component {
  render() {
    return <button>{this.props.label}</button>;
  }
}
```

- **用途**

    1. 组件就是**构建 UI 的基本单元**。
    2. 允许你在应用中拆分、组合和复用 UI 逻辑。
- **与 Element/Instance 的关系**

    1. 在运行时，**组件**会被 React 调用（或者说“实例化”），从而返回一个或多个 **React Element**。
    2. 对于类组件来说，React 也会创建组件的**实例对象**来管理生命周期和状态。
    3. 对于函数组件来说，并不会创建传统的“实例对象”，但内部依然有对应的数据结构（fiber）来跟踪其状态和渲染过程。

---

### 2. Element（元素）

- **React 元素 = 用于描述 UI 的**“**轻量对象**”
    
    - React 元素是一个**纯粹的、不可变的 JavaScript 对象**，它包含以下关键信息：
        - `type`：可以是一个字符串（如 `"div"`，表示 DOM 标签）或者一个 React 组件（如 `MyButton`）。
        - `props`：组件/标签的属性对象。
        - `key`：列表渲染时用于标识元素的唯一性。
        - 等等。
- **创建方式**
    
    - 通过 JSX 语法或 `React.createElement` 来创建 React 元素。
    - 例如，JSX `<div className="box" />` 最终被编译为 `React.createElement('div', { className: 'box' }, null)`。
    - 或者，一个函数组件 `<MyButton label="Click Me" />` 则对应 `React.createElement(MyButton, { label: 'Click Me' }, null)`。
- **特点**
    
    1. **不可变**：一旦创建，元素对象的内容就不会变更。如果需要更新 UI，React 会创建新的元素并对比新旧元素（通过虚拟 DOM diff）。
    2. **描述层**：可以把 React 元素理解为一份 **“视图的声明”**，即告诉 React **“想要渲染什么”**。
- **与 Component/Instance 的关系**
    
    1. **元素**在 React 中是最基本的组成单位，**组件的 `render()` 方法就是返回 React 元素**。
    2. React 在执行过程中，会根据元素的 `type` 判断是原生 DOM 标签还是自定义组件。如果是**自定义组件**，则会去**实例化对应的组件**（类组件）或执行对应的函数组件（函数组件）。
    3. **元素**是“静态结构”，而**组件**可以包含状态和生命周期，可动态决定元素的结构与内容。

---

### 3. Instance（实例）

- **概念背景**
    
    - 在传统面向对象的思路里，“实例”是通过 `new SomeClass()` 生成的对象。
    - 在 React **类组件** 中，`Instance` 就是通过 `new MyButton(...)` 生成的 **组件实例对象**。
    - 在 React **函数组件** 中，并不会真正创建传统的“实例对象”，因为函数组件就是一个普通函数。但 React 内部会创建对应的**Fiber节点**来跟踪该组件的状态与生命周期逻辑。
- **工作流程**
    
    1. 当 React 遇到 `<MyButton />` 时，会判断：
        - 如果 `MyButton` 是一个类组件，则 `React` 会调用 `new MyButton(props)` 来生成一个**实例**，并调用它的 `render()` 返回元素。
        - 如果 `MyButton` 是一个函数组件，则直接执行 `MyButton(props)`，不会有传统面向对象的实例，但依然会有内部 Fiber 结构来记载它的状态、Hooks 等。
    2. 对于 **类组件**，Instance 负责：
        - 存储组件的状态 `this.state`
        - 存储对 `this.props` 的引用
        - 管理组件的**生命周期方法**（如 `componentDidMount`、`componentDidUpdate` 等）
    3. 对于 **函数组件**，没有“this”，也没有显式的实例对象，但 React 在内部会创建“**Fiber**”来保持 Hook 的状态和执行队列。
- **与 Component/Element 的关系**
    
    1. **组件**是一个**定义**或**抽象**（函数或类），实例是组件类在运行时的一个**具体对象**。
    2. **元素**是一个用来描述 UI 的对象，React 在渲染时会根据元素的信息去**创建或者更新**组件实例（对类组件而言）。
    3. React 通过**元素 -> (可能) 实例 -> render() -> 新元素**这一流程，不断进行更新和渲染。

---

### 4. 三者之间的区别与联系

1. **Component**
    - **是什么**：定义组件的蓝图或抽象（函数或类）。
    - **作用**：编写渲染逻辑（`render` 方法或者函数返回 JSX）和管理组件的内部状态（对于类组件/Hook）。
    - **关系**：只有在渲染时（或者说 React 解析到相应的元素时）才会被真正调用或实例化。
2. **Element**
    - **是什么**：不可变的对象，描述要渲染的内容和层级结构（“虚拟 DOM”节点）。
    - **作用**：告诉 React 如何渲染 UI。由 JSX 或 `React.createElement` 创建。
    - **关系**：组件的 `render` 或返回值最终都会成为一个或多个 React 元素。React 也会根据这些元素的 `type` 去决定是否生成/更新对应的 DOM 或组件实例。
3. **Instance**
    
    - **是什么**：对**类组件**来说，Instance 就是 `new MyClass()` 出来的对象，包含 `this.state`、生命周期方法等。对**函数组件**则没有“实例”概念，但有内部的 Fiber 用于管理状态和副作用等。
    - **作用**：保存组件的内部状态，处理生命周期回调。
    - **关系**：在对元素进行渲染时，如果该元素的 `type` 是一个类组件，React 就会创建或更新对应的实例；函数组件则不创建传统实例，但依然有抽象的 Fiber 对应组件。

---

### 5. 总结与类比

- **Component**：类似于**类或构造器**的定义，本身只是一个静态概念或蓝图。
- **Element**：类似于**实例化指令**，描述了“我想渲染什么组件、什么 DOM、传入什么属性”，形成一个**不可变的“UI 配方”**。
- **Instance**：对于类组件，就是真正用 `new` 关键字生成的对象，包含 `this.state`、`this.props` 等所有内部逻辑。对于函数组件，虽没有传统实例，但 React 依然以内部数据结构（Fiber）去跟踪其渲染状态。

从渲染流程上可以这么理解：

1. 你编写了一个 **Component** （函数或类）。
2. 在 **JSX** 中使用 `<MyComponent />` 时，React 会创建一个 **Element**（即 `{ type: MyComponent, props: {} }` 这样的对象）。
3. React 根据 **Element** 的 `type` 判断这是一个函数还是类组件。
    - 如果是类组件，则创建一个 **Instance**（`new MyComponent(props)`），再执行 `render()` 返回新的 Element。
    - 如果是函数组件，则直接调用该函数并返回新的 Element（内部仍会有 Fiber 节点追踪状态）。
4. 最终根据组件返回的那个 Element 决定下一步渲染或更新 DOM、形成完整 UI 树。

通过以上流程可以看到，**Component** 是**定义**，**Element** 是**渲染描述**，**Instance**（或 Fiber）则是**实际在内存中管理状态和生命周期的实体**。三者在 React 中共同构成了从“编写组件”到“渲染并管理组件”的完整体系。
## 8. React.createClass和extends Component的区别有哪些？
在 React 早期版本（15 及之前），创建类组件主要有两种方式：**`React.createClass()`** 和 **`extends React.Component`**。但在 React 16 之后，`React.createClass()` 已经被废弃，推荐使用 `class extends React.Component`。下面详细对比它们的区别。

---

### 1. `React.createClass()` 和 `extends React.Component` 的核心区别

| 特性         | `React.createClass()`（已废弃）                          | `class extends React.Component`                      |
| ---------- | --------------------------------------------------- | ---------------------------------------------------- |
| **状态管理**   | `getInitialState()` 方法返回状态对象                        | 直接在 `constructor()` 里初始化 `this.state`                |
| **方法绑定**   | 自动绑定组件方法到 `this`（不需要手动 `.bind(this)`)               | 需要手动 `.bind(this)` 或使用箭头函数                           |
| **ES 语法**  | 纯 JavaScript 方式，不使用 ES6 语法                          | 依赖 ES6 类                                             |
| **生命周期方法** | 生命周期方法使用 `componentWillMount`、`componentDidMount` 等 | 仍然使用相同的生命周期方法（但支持新生命周期，如 `getDerivedStateFromProps`） |
| **可维护性**   | 代码风格较旧，已被废弃，不再支持                                    | 推荐的现代写法，支持所有新特性                                      |
| **性能**     | 由于 `bind` 开销，性能稍低                                   | 更高效，避免不必要的 `bind`                                    |

---

### 2. `React.createClass()`（已废弃）的用法

在 React 15 及之前，组件是通过 `React.createClass()` 创建的：

```jsx
var MyComponent = React.createClass({
  getInitialState: function () {
    return { count: 0 };
  },
  handleClick: function () {
    this.setState({ count: this.state.count + 1 });
  },
  render: function () {
    return (
      <div>
        <p>计数：{this.state.count}</p>
        <button onClick={this.handleClick}>+1</button>
      </div>
    );
  },
});

ReactDOM.render(<MyComponent />, document.getElementById("root"));
```

#### `React.createClass()` 的特点：

1. **自动绑定 `this`**
    - `React.createClass()` 会自动绑定组件的方法到实例，因此在事件处理时**不需要手动 `.bind(this)`**。
    - 例如：`this.handleClick` 直接传递给 `onClick` 仍然能正确访问 `this.state`，而不需要 `this.handleClick.bind(this)`。
2. **状态初始化使用 `getInitialState()`**
    - 这个方法返回一个初始状态对象，而不是在 `constructor()` 里定义 `this.state`。
3. **缺点**
    - 由于 `React.createClass()` **自动绑定** 方法，每次创建组件时都会创建新的函数实例，影响性能。
    - 不支持 ES6 语法，如 `class`、`constructor()`，以及新的生命周期方法（如 `getDerivedStateFromProps`）。

> `React.createClass()` 在 React 16 之后被完全移除，官方推荐使用 `class extends React.Component` 方式创建组件。

---

### 3. `class extends React.Component`（推荐方式）

React 16 及之后推荐使用 **ES6 class 语法** 创建组件：

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
    this.handleClick = this.handleClick.bind(this); // 手动绑定
  }

  handleClick() {
    this.setState({ count: this.state.count + 1 });
  }

  render() {
    return (
      <div>
        <p>计数：{this.state.count}</p>
        <button onClick={this.handleClick}>+1</button>
      </div>
    );
  }
}

ReactDOM.render(<MyComponent />, document.getElementById("root"));
```

### `class extends React.Component` 的特点：

4. **不自动绑定 `this`**
    
    - 组件的方法不会默认绑定到实例，所以**在事件回调中需要手动 `.bind(this)`**，否则 `this` 为 `undefined`。
    - 解决方法：
        - 在 `constructor()` 里 `this.handleClick = this.handleClick.bind(this);`
        - 使用箭头函数 `handleClick = () => {}`
5. **状态管理方式不同**
    
    - 在 `constructor()` 里定义 `this.state`，不再使用 `getInitialState()`。
6. **支持 ES6 语法**
    
    - 支持 ES6+ 类、继承、`super()` 调用等现代特性，代码更清晰。
7. **性能更好**
    
    - 由于 `class` 组件不会自动绑定 `this`，开发者可以手动优化 `bind`，减少不必要的内存占用。

---

### 4. `class` 组件中的 `this` 绑定问题及解决方案

由于 `class` 组件**不会自动绑定 `this`**，所以事件回调中 `this` 可能会变成 `undefined`，例如：

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = { count: 0 };
  }

  handleClick() {
    console.log(this.state.count); // this 可能是 undefined
  }

  render() {
    return <button onClick={this.handleClick}>点击</button>;
  }
}
```

#### 解决方案：

1. **在 `constructor` 里手动绑定**

  ```jsx
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  ```
  
2. **使用箭头函数**
```jsx
handleClick = () => {
  console.log(this.state.count);
};
```

3. **直接在 `onClick` 里使用箭头函数**
```jsx
<button onClick={() => this.handleClick()}>点击</button>
```
- 但这样会导致**每次渲染都创建一个新的函数**，影响性能。

---

### 5. 为什么 `React.createClass()` 被废弃？

- **`React.createClass()` 方式较老，不符合 ES6 标准**，而 React 正在拥抱现代 JavaScript 语法。
- **自动绑定 `this` 带来性能损耗**，每次创建组件实例都会创建新的方法，浪费内存。
- **不支持 ES6 `class` 及其特性**，如 `super()`、`constructor()`、`extends` 等，导致代码难以迁移和维护。
- **新的生命周期方法（如 `getDerivedStateFromProps`）不兼容** `React.createClass()`，无法支持最新的 React 特性。

---

### 6. 总结对比

|特性|`React.createClass()`（已废弃）|`class extends React.Component`（推荐）|
|---|---|---|
|**状态管理**|`getInitialState()`|`constructor() -> this.state`|
|**方法绑定**|自动绑定 `this`|需要手动 `bind` 或使用箭头函数|
|**ES6 兼容性**|不支持|完全支持|
|**生命周期方法**|旧生命周期|兼容所有新旧生命周期|
|**性能**|由于自动 `bind`，可能更低|更高效|
|**现代化支持**|已废弃，不推荐使用|推荐使用|
|**适用场景**|旧代码（React 15 及以下）|React 16+ 及未来版本|

### **结论**

- `React.createClass()` **已被废弃**，不应在现代 React 项目中使用。
- `class extends React.Component` **是推荐的方式**，支持所有现代 React 特性。
- **如果可能，建议使用** **函数组件 + Hooks**，避免 `class` 组件的 `this` 绑定问题，代码更简洁可读：

```jsx
function Counter() {
  const [count, setCount] = React.useState(0);
  return <button onClick={() => setCount(count + 1)}>+1</button>;
}
```

## 9. React 高阶组件是什么，和普通组件有什么区别，适用什么场景

**高阶组件（Higher-Order Component，HOC）** 是一种基于 React 组件复用的设计模式。

它本质上是一个函数，接受一个组件作为参数，并返回一个经过增强的新组件。

---

### 1. 什么是高阶组件

- **定义**：  
  高阶组件就是一个函数，形如：
```jsx
const EnhancedComponent = higherOrderComponent(WrappedComponent);
```
  
  它接受一个组件 `WrappedComponent`，并返回一个新的组件 `EnhancedComponent`。
- **原理**：  
    HOC 通过**组合**（composition）的方式增强传入的组件，实现代码逻辑的复用，而不修改原有组件的定义。

---

### 2. 高阶组件和普通组件的区别

| 特性       | 普通组件                 | 高阶组件 (HOC)                    |
| -------- | -------------------- | ----------------------------- |
| **目的**   | 用于描述 UI 和交互逻辑        | 用于复用和增强组件的逻辑，通过包装和组合来注入额外的功能  |
| **写法**   | 通常通过函数组件或 class 组件编写 | 是一个函数，接受组件作为参数返回一个新的组件        |
| **职责单一** | 通常关注自身的业务逻辑和 UI 展现   | 关注横切关注点，如权限校验、数据获取、日志记录、状态管理等 |
| **复用性**  | 一般针对单个业务场景           | 可以将通用功能抽象出来，通过 HOC 应用于多个组件    |

- **增强复用**：  
    HOC 可以将多个组件中重复的逻辑提取出来，进行统一处理，避免代码重复。

- **包装组件**：  
    HOC 会包裹被增强组件，将额外的 props 注入其中，同时也可能拦截或修改生命周期等。

---

### 3. 适用场景

#### 3.1 通用逻辑复用

当多个组件中需要使用相同的逻辑时，可以使用 HOC 统一处理，例如：

- **权限控制**：包装组件，判断用户是否有权限访问某些内容。
- **数据获取**：封装网络请求逻辑，自动注入数据和 loading 状态。
- **日志记录**：拦截组件的生命周期、渲染次数等，进行统计或调试。

#### 3.2 组件增强

在不修改原有组件代码的情况下，通过 HOC 为组件增加新的功能，如：

- **响应式布局**：为组件注入屏幕尺寸、滚动位置等数据。
- **错误边界**：包装组件，在出现错误时捕获异常并显示备用 UI。

#### 3.3 状态管理

- **跨组件共享状态**：通过 HOC 来实现状态的共享或注入，使得多个组件之间可以访问同一份数据逻辑。

---

### 4. 示例

#### 示例：数据获取 HOC

假设我们有一个 HOC 用于从 API 获取数据，并将数据注入到被包装组件中。

```jsx
// withData.js - 定义 HOC
import React from 'react';

function withData(WrappedComponent, url) {
  return class extends React.Component {
    state = {
      data: null,
      loading: true,
      error: null,
    };

    componentDidMount() {
      fetch(url)
        .then(response => response.json())
        .then(data => this.setState({ data, loading: false }))
        .catch(error => this.setState({ error, loading: false }));
    }

    render() {
      // 将状态通过 props 传递给被包装组件
      return <WrappedComponent {...this.props} {...this.state} />;
    }
  }
}

export default withData;
```

使用方式：

```jsx
// MyComponent.js - 普通组件
import React from 'react';

function MyComponent({ data, loading, error }) {
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error!</div>;
  return (
    <ul>
      {data.map(item => <li key={item.id}>{item.name}</li>)}
    </ul>
  );
}

export default MyComponent;
```

```jsx
// 使用 HOC 增强组件
import withData from './withData';
import MyComponent from './MyComponent';

const EnhancedMyComponent = withData(MyComponent, 'https://api.example.com/items');

export default EnhancedMyComponent;
```

在这个例子中，`withData` HOC 负责处理数据获取的逻辑，而 `MyComponent` 只专注于如何展示数据。

---

### 5. 注意事项

- **静态属性和引用问题**：  
    使用 HOC 时，需要注意被包装组件的静态方法和属性可能不会自动传递，可以使用工具函数（例如 `hoist-non-react-statics`）来复制静态属性。
    
- **不要滥用**：  
    HOC 是一种强大的抽象，但过度使用可能会使组件层次变得复杂，导致调试和维护困难。在适用场景中使用，能提高代码复用性。
    
- **命名约定**：  
    通常在 HOC 内部，使用 `WrappedComponent` 表示被包装的组件，新组件可以命名为 `WithXXX` 或 `EnhancedComponent` 等。
    

---

### 6. 小结

- **高阶组件（HOC）**：是一种通过函数包装组件实现复用逻辑和增强功能的设计模式。
- **区别**：
    - 普通组件关注具体的 UI 与业务逻辑；
    - HOC 关注横切关注点（如数据获取、权限校验、日志记录等），并通过组合的方式提升代码复用性。
- **适用场景**：
    - 当多个组件需要共用同一逻辑或功能时；
    - 需要对组件进行增强而不改变原组件代码时；
    - 管理跨组件状态或行为时。

通过使用高阶组件，我们可以将重复逻辑抽离出来，使得代码更加模块化、易于维护，同时也能为现有组件注入新的功能。

## 10. 对componentWillReceiveProps 的理解

### 1. `componentWillReceiveProps` 的作用

`componentWillReceiveProps(nextProps)` 是 React **旧生命周期**中的一个方法，**在组件接收到新的 `props` 但还未 `render` 之前执行**。

- **触发条件**：
    - **不会在组件初始化时调用**，即组件首次 `render` 时不会触发。
    - **只会在组件的 `props` 发生变化时调用**，即 `this.props` 和 `nextProps` 不一样时触发。
- **典型用途**：
    - **基于新的 `props` 更新 `state`**：
        - 在 `componentWillReceiveProps` 中，可以通过 `this.setState()` 来更新组件的 `state`，以同步 `props` 的变化。
    - **数据请求或计算**：
        - 适用于根据新 `props` 触发 API 请求或进行某些计算，但更推荐使用 `componentDidUpdate`。

---

#### **2. 示例代码**

```jsx
class ChildComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: props.initialValue,
    };
  }

  // 旧生命周期方法（React 16 及之前）
  componentWillReceiveProps(nextProps) {
    console.log("旧 props:", this.props);
    console.log("新 props:", nextProps);

    // 当 props 变化时，更新 state
    if (nextProps.initialValue !== this.props.initialValue) {
      this.setState({ value: nextProps.initialValue });
    }
  }

  render() {
    return <p>当前值: {this.state.value}</p>;
  }
}

// 父组件
class ParentComponent extends React.Component {
  state = { count: 0 };

  updateCount = () => {
    this.setState({ count: this.state.count + 1 });
  };

  render() {
    return (
      <div>
        <button onClick={this.updateCount}>更新 count</button>
        <ChildComponent initialValue={this.state.count} />
      </div>
    );
  }
}

export default ParentComponent;
```

**说明：**

- 每次点击按钮，父组件 `ParentComponent` 的 `state.count` 发生变化。
- `ChildComponent` 由于 `props.initialValue` 变化，`componentWillReceiveProps` 被触发，从而更新 `state.value`。

---

#### **3. `componentWillReceiveProps` 存在的问题**

- **不够直观**
    - 它会在 `props` 变化时触发，但 React 16+ 提供了更好的方式来处理 `props` 变化，如 `getDerivedStateFromProps`。
- **容易导致不必要的 `setState`**
    - 如果 `setState` 不加判断条件，可能导致组件频繁更新，影响性能。
- **在 React 16.3+ 被废弃**
    - React 官方不推荐使用该方法，并在 16.3 版本之后**废弃**，可以改用 `getDerivedStateFromProps` 或 `componentDidUpdate`。

---

#### **4. 替代方案**

##### **(1) `getDerivedStateFromProps`（React 16.3+）**

**推荐替代 `componentWillReceiveProps`**，它是一个**静态方法**，不能访问 `this`，只能返回新的 `state` 对象或 `null`。

```jsx
class ChildComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: props.initialValue,
    };
  }

  static getDerivedStateFromProps(nextProps, prevState) {
    if (nextProps.initialValue !== prevState.value) {
      return { value: nextProps.initialValue };
    }
    return null;
  }

  render() {
    return <p>当前值: {this.state.value}</p>;
  }
}
```

- `getDerivedStateFromProps` 用于根据新的 `props` 更新 `state`。
- 由于是**静态方法**，无法访问 `this`，因此不能在其中执行副作用（如 API 请求）。

##### **(2) `componentDidUpdate`（推荐用于副作用）**

如果 `componentWillReceiveProps` 中的代码是为了触发 API 请求或其他副作用，建议使用 `componentDidUpdate`：

```jsx
class ChildComponent extends React.Component {
  componentDidUpdate(prevProps) {
    if (prevProps.initialValue !== this.props.initialValue) {
      console.log("Props 变化了，可以在这里执行 API 请求");
    }
  }

  render() {
    return <p>当前值: {this.props.initialValue}</p>;
  }
}
```

- `componentDidUpdate` 适用于**在 `props` 变化后执行副作用**（如 API 请求）。
- 与 `componentWillReceiveProps` 不同，它是在 `render` 之后执行的。

---

#### **5. `componentWillReceiveProps` 在函数组件中的替代方案**

在**函数组件**中，`useEffect` 可以替代 `componentWillReceiveProps` 处理 `props` 变化：

```jsx
import React, { useState, useEffect } from "react";

function ChildComponent({ initialValue }) {
  const [value, setValue] = useState(initialValue);

  useEffect(() => {
    setValue(initialValue);
  }, [initialValue]); // 依赖项发生变化时触发

  return <p>当前值: {value}</p>;
}
```

- `useEffect` 会在 `initialValue` 变化时执行，类似于 `componentWillReceiveProps`，但更符合现代 React 习惯。
- **推荐在 Hooks 组件中使用 `useEffect` 来处理 `props` 变化，而不是 `componentWillReceiveProps`。**

---

#### **6. 结论**

- `componentWillReceiveProps` **已被废弃**，不推荐在新项目中使用。
- 替代方案：
    - **如果是更新 `state`，推荐使用 `getDerivedStateFromProps`**。
    - **如果是副作用（如 API 请求），推荐使用 `componentDidUpdate` 或 `useEffect`**。
- **函数组件** 推荐使用 **`useEffect`** 处理 `props` 变化。

---

### ✅ **最佳实践**

|场景|推荐方法|
|---|---|
|需要根据 `props` 更新 `state`|`getDerivedStateFromProps`|
|需要在 `props` 变化后执行副作用（如 API 请求）|`componentDidUpdate` 或 `useEffect`|
|使用函数组件|`useEffect`|

这样，我们可以避免 `componentWillReceiveProps` 带来的问题，同时符合 React **最新的最佳实践**。🚀

## 11. 哪些方法会触发 React 重新渲染？重新渲染 render 会做些什么？

React 组件的 `render()` 方法是 React 更新 UI 的核心部分，以下情况会触发组件的重新渲染：



---

### 1. `setState()` 触发重新渲染

- **当组件的 `state` 发生变化时，React 会重新渲染组件。**
- **`setState()` 是异步的**，React 会批量更新多个 `setState()` 调用以提高性能。
- **例子：**
    
    ```jsx
    class Counter extends React.Component {
      constructor(props) {
        super(props);
        this.state = { count: 0 };
      }
    
      increment = () => {
        this.setState({ count: this.state.count + 1 }); // 触发重新渲染
      };
    
      render() {
        console.log("组件重新渲染");
        return (
          <div>
            <p>计数: {this.state.count}</p>
            <button onClick={this.increment}>+1</button>
          </div>
        );
      }
    }
    ```
    
    **注意：**
    - React 会合并**多次 `setState()` 调用**，减少不必要的渲染，提高性能。
    - `setState()` 可以使用**回调形式**以确保正确的 `prevState`：

```jsx
this.setState((prevState) => ({ count: prevState.count + 1 }));
```

---

### 2. `forceUpdate()` 触发重新渲染

- `this.forceUpdate()` **会强制触发 `render()` 方法，即使 `state` 没有改变。**
- **例子：**

```jsx
class ForceUpdateExample extends React.Component {
  forceRerender = () => {
    this.forceUpdate(); // 强制重新渲染
  };

  render() {
    console.log("组件重新渲染");
    return <button onClick={this.forceRerender}>强制刷新</button>;
  }
}
```

**注意：**
- `forceUpdate()` **不推荐使用**，因为它跳过了 React 的优化机制，可能会导致不必要的渲染。
- 在大多数情况下，正确更新 `state` 而不是使用 `forceUpdate()` 是更好的做法。

---

### 3. 父组件重新渲染，子组件也会跟着重新渲染

- **当父组件 `render()` 触发时，默认情况下子组件也会重新渲染，即使 `props` 没有变化。**

- **例子：**

```jsx
class Parent extends React.Component {
  state = { count: 0 };

  increment = () => {
    this.setState({ count: this.state.count + 1 }); // 触发 Parent 重新渲染
  };

  render() {
    console.log("Parent 组件重新渲染");
    return (
      <div>
        <button onClick={this.increment}>+1</button>
        <Child name="React" />
      </div>
    );
  }
}

function Child({ name }) {
  console.log("Child 组件重新渲染");
  return <p>Hello, {name}</p>;
}
```

 **输出日志**
 
 ```
 Parent 组件重新渲染
 Child 组件重新渲染
 ```
 
 - **即使 `Child` 组件的 `props` 没有改变，它仍然会重新渲染**，因为 `Parent` 重新渲染时，默认情况下所有子组件都会重新渲染。

**优化方法：使用 `React.memo`**

- 如果子组件 `props` 没有变化，我们可以用 `React.memo()` 让它跳过不必要的渲染：

```jsx
const Child = React.memo(function Child({ name }) {
  console.log("Child 组件重新渲染");
  return <p>Hello, {name}</p>;
});
```

这样，`Child` 组件只会在 `props` 变化时重新渲染，而不是每次 `Parent` 重新渲染时都更新。

---

### 4. `useState()` 或 `useReducer()` 触发重新渲染

- 在 **函数组件** 中，调用 `useState` 的 `setState()` 方法或者 `useReducer` 的 `dispatch` 方法都会导致组件重新渲染。
- **示例（`useState`）：**
```jsx
function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  );
}
```

- **示例（`useReducer`）：**
    ```jsx
    function reducer(state, action) {
      switch (action.type) {
        case "increment":
          return { count: state.count + 1 };
        default:
          return state;
      }
    }
    
    function Counter() {
      const [state, dispatch] = React.useReducer(reducer, { count: 0 });
    
      return (
        <div>
          <p>Count: {state.count}</p>
          <button onClick={() => dispatch({ type: "increment" })}>+1</button>
        </div>
      );
    }
    ```
    
    **注意：**
    - `setState`/`dispatch` **不会立即生效**，React **会批量合并**多次状态更新以优化性能。
    - **相同值不会触发重新渲染**（即 `setCount(0)` 不会触发 `render()`，因为 `count` 没有变化）。

---

### React 重新渲染时，`render()` 方法做了什么？

当组件重新渲染时，React 会执行以下步骤：

1. **调用 `render()` 或 函数组件重新执行**
    - React 会调用组件的 `render()` 方法（类组件）或**重新执行**整个**函数组件**（函数组件）。
    - **示例（类组件）**：
```jsx
class MyComponent extends React.Component {
  render() {
  }
}
```

 - **示例（函数组件）**：
```jsx
function MyComponent() {
  console.log("组件重新渲染");
  return <p>Hello, World!</p>;
}
```

 - **每次 `setState()` 或 `props` 变化时，`render()` 都会被调用**。
2. **比较虚拟 DOM（Virtual DOM）**
    
    - React 使用 **Diffing Algorithm**（**React Reconciliation**），比较新的 `Virtual DOM` 和之前的 `Virtual DOM`，找出哪些部分发生了变化。
3. **计算最小更新**

    - React **不会直接更新整个 DOM，而是最小化 DOM 更新**，只更新**变化的部分**。
    - 例如：

```jsx
<div>
  <p>原内容</p>
</div>
```

更新后：
```jsx
<div>
  <p>新内容</p> <!-- 只更新这个 <p> 标签 -->
</div>
```

1. **更新真实 DOM**
    - React 使用 **批量更新（Batch Updates）** 来提高性能，而不是每次 `setState()` 变化都立即操作 DOM。

---

### 小结

#### ✅ 可以触发 React 重新渲染的方法

2. `this.setState()`（类组件）
3. `forceUpdate()`（强制更新，不推荐）
4. `useState()` / `useReducer()`（函数组件）
5. 父组件 `render()` 时，子组件默认也会重新渲染（可用 `React.memo` 优化）
6. `useContext()` 依赖的 `value` 变化

#### ✅ React 重新渲染时 `render()` 做了什么？

7. 重新执行 `render()`（类组件）或重新执行函数组件
8. **比较新的 Virtual DOM 和旧的 Virtual DOM**
9. 计算最小 DOM 更新
10. **高效更新真实 DOM**

**优化技巧：**

- 避免不必要的 `setState()`
- 使用 `React.memo` 避免子组件重复渲染
- `useCallback()` & `useMemo()` 优化函数组件的性能
- 使用 **不可变数据（Immutable Data）** 避免对象引用不变但内容变化时的无效渲染


## 12. React如何判断什么时候重新渲染组件？

组件状态的改变可以因为`props`的改变，或者直接通过`setState`方法改变。组件获得新的状态，然后React决定是否应该重新渲染组件。只要组件的state发生变化，React就会对组件进行重新渲染。这是因为React中的`shouldComponentUpdate`方法默认返回`true`，这就是导致每次更新都重新渲染的原因。

当React将要渲染组件时会执行`shouldComponentUpdate`方法来看它是否返回`true`（组件应该更新，也就是重新渲染）。所以需要重写`shouldComponentUpdate`方法让它根据情况返回`true`或者`false`来告诉React什么时候重新渲染什么时候跳过重新渲染。

## 13. React声明组件有哪几种方法，有什么不同？

React 声明组件的三种方式：

- 函数式定义的`无状态组件`
- ES5原生方式`React.createClass`定义的组件
- ES6形式的`extends React.Component`定义的组件

**（1）无状态函数式组件** 它是为了创建纯展示组件，这种组件只负责根据传入的props来展示，不涉及到state状态的操作 组件不会被实例化，整体渲染性能得到提升，不能访问this对象，不能访问生命周期的方法

**（2）ES5 原生方式 React.createClass // RFC** `React.createClass`会自绑定函数方法，导致不必要的性能开销，增加代码过时的可能性。

**（3）E6继承形式 React.Component // RCC** 目前极为推荐的创建有状态组件的方式，最终会取代React.createClass形式；相对于 React.createClass可以更好实现代码复用。

**无状态组件相对于于后者的区别：** 与无状态组件相比，React.createClass和React.Component都是创建有状态的组件，这些组件是要被实例化的，并且可以访问组件的生命周期方法。

**React.createClass与React.Component区别：**

**① 函数this自绑定**

- React.createClass创建的组件，其每一个成员函数的this都有React自动绑定，函数中的this会被正确设置。
- React.Component创建的组件，其成员函数不会自动绑定this，需要开发者手动绑定，否则this不能获取当前组件实例对象。

**② 组件属性类型propTypes及其默认props属性defaultProps配置不同**

- React.createClass在创建组件时，有关组件props的属性类型及组件默认的属性会作为组件实例的属性来配置，其中defaultProps是使用getDefaultProps的方法来获取默认组件属性的
- React.Component在创建组件时配置这两个对应信息时，他们是作为组件类的属性，不是组件实例的属性，也就是所谓的类的静态属性来配置的。

**③ 组件初始状态state的配置不同**

- React.createClass创建的组件，其状态state是通过getInitialState方法来配置组件相关的状态；
- React.Component创建的组件，其状态state是在constructor中像初始化组件属性一样声明的。

## 14. 对有状态组件和无状态组件的理解及使用场景

**（1）有状态组件**

**特点：**

- 是类组件
- 有继承
- 可以使用this
- 可以使用react的生命周期
- 使用较多，容易频繁触发生命周期钩子函数，影响性能
- 内部使用 state，维护自身状态的变化，有状态组件根据外部组件传入的 props 和自身的 state进行渲染。

**使用场景：**

- 需要使用到状态的。
- 需要使用状态操作组件的（无状态组件的也可以实现新版本react hooks也可实现）

**总结：** 类组件可以维护自身的状态变量，即组件的 state ，类组件还有不同的生命周期方法，可以让开发者能够在组件的不同阶段（挂载、更新、卸载），对组件做更多的控制。类组件则既可以充当无状态组件，也可以充当有状态组件。当一个类组件不需要管理自身状态时，也可称为无状态组件。

**（2）无状态组件** **特点：**

- 不依赖自身的状态state
- 可以是类组件或者函数组件。
- 可以完全避免使用 this 关键字。（由于使用的是箭头函数事件无需绑定）
- 有更高的性能。当不需要使用生命周期钩子时，应该首先使用无状态函数组件
- 组件内部不维护 state ，只根据外部组件传入的 props 进行渲染的组件，当 props 改变时，组件重新渲染。

**使用场景：**

- 组件不需要管理 state，纯展示

**优点：**

- 简化代码、专注于 render
- 组件不需要被实例化，无生命周期，提升性能。 输出（渲染）只取决于输入（属性），无副作用
- 视图和数据的解耦分离

**缺点：**

- 无法使用 ref
- 无生命周期方法
- 无法控制组件的重渲染，因为无法使用shouldComponentUpdate 方法，当组件接受到新的属性时则会重渲染

**总结：** 组件内部状态且与外部无关的组件，可以考虑用状态组件，这样状态树就不会过于复杂，易于理解和管理。当一个组件不需要管理自身状态时，也就是无状态组件，应该优先设计为函数组件。比如自定义的 `<Button/>`、 `<Input />` 等组件。

## 15. 对React中Fragment的理解，它的使用场景是什么？

### 1. 什么是 `React.Fragment`？

`React.Fragment` 是 React 提供的一种特殊组件，用于**在不增加额外 DOM 结构的情况下，返回多个元素**。

在 React 组件中，`render()` 方法（或函数组件）**只能返回一个根元素**。但有时候，我们需要**返回多个 JSX 元素，而不想在 DOM 结构中添加额外的 `<div>` 包裹层**，这时就可以使用 `React.Fragment`。

---

### 2. 为什么需要 `React.Fragment`？

在 React 早期版本中，如果想要在 `render()` 方法返回多个元素，通常会使用 `<div>` 包裹所有子元素，例如：

```jsx
function MyComponent() {
  return (
    <div>
      <h1>标题</h1>
      <p>这是一个段落</p>
    </div>
  );
}
```

虽然这样可以正常工作，但它**会在 DOM 结构中增加额外的 `<div>`，可能会影响布局或样式**，例如：

```html
<div>  <!-- 额外的 div -->
  <h1>标题</h1>
  <p>这是一个段落</p>
</div>
```

如果在一些严格的 HTML 结构中，比如 `<ul>` 或 `<table>`，额外的 `<div>` 可能会导致语法错误或影响样式。

---

### 3. 使用 `React.Fragment` 解决问题

使用 `React.Fragment`，可以避免额外的 `<div>`，让 JSX 直接返回多个元素，而不影响 DOM 结构：

```jsx
function MyComponent() {
  return (
    <React.Fragment>
      <h1>标题</h1>
      <p>这是一个段落</p>
    </React.Fragment>
  );
}
```

最终生成的 DOM 结构：

```html
<h1>标题</h1>
<p>这是一个段落</p>
```

这样就不会有额外的 `<div>` 影响布局。

---

### 4. `React.Fragment` 的简写形式

React 提供了**简写语法**：`<>...</>`，可以减少代码量：

```jsx
function MyComponent() {
  return (
    <>
      <h1>标题</h1>
      <p>这是一个段落</p>
    </>
  );
}
```

这个 `<>...</>` 语法与 `React.Fragment` 完全等效，但更简洁。

---

### 5. `React.Fragment` 的使用场景

#### (1) 避免不必要的 DOM 结构

有时，多个组件需要被一起返回，但不希望增加额外的 `div`，这时 `Fragment` 很有用：

```jsx
function ListItems() {
  return (
    <React.Fragment>
      <li>Item 1</li>
      <li>Item 2</li>
      <li>Item 3</li>
    </React.Fragment>
  );
}

function MyList() {
  return (
    <ul>
      <ListItems />
    </ul>
  );
}
```

如果用 `<div>` 包裹 `li`，会导致 HTML 结构不合法：

```html
<ul>
  <div> <!-- ❌ 错误：<div> 不能直接包裹 <li> -->
    <li>Item 1</li>
    <li>Item 2</li>
    <li>Item 3</li>
  </div>
</ul>
```

使用 `React.Fragment` 后：

```html
<ul>
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>
```

✅ **不会影响 `ul` 的正确性**。

---

#### (2) 在 `table` 结构中避免额外 DOM 影响布局

HTML 中，`table` 的 `thead`、`tbody`、`tr` 结构必须严格遵守规范，不能随意插入 `div`，否则可能导致样式或布局问题：

```jsx
function TableRow() {
  return (
    <>
      <tr>
        <td>张三</td>
        <td>28</td>
      </tr>
      <tr>
        <td>李四</td>
        <td>30</td>
      </tr>
    </>
  );
}

function MyTable() {
  return (
    <table>
      <thead>
        <tr>
          <th>姓名</th>
          <th>年龄</th>
        </tr>
      </thead>
      <tbody>
        <TableRow />
      </tbody>
    </table>
  );
}
```

如果这里用 `<div>` 包裹 `<tr>`，浏览器可能会自动修正错误的 HTML 结构，导致意外的布局问题。而 `Fragment` 允许你返回多个 `tr`，不会影响 `table` 结构。

---

#### (3) 提高渲染性能

`React.Fragment` **比 `<div>` 具备更好的性能**：

- **减少 DOM 节点的数量**，提高渲染性能，减少不必要的 DOM 计算。
- **特别适合 React 组件树深度较深的场景**，避免不必要的嵌套结构。

---

### 6. `React.Fragment` 的 `key` 属性

在 `map()` 渲染列表时，通常需要 `key` 标识唯一性，但 `<>...</>` 语法不支持 `key`，需要用 `React.Fragment`：

```jsx
function List() {
  const items = ["苹果", "香蕉", "橙子"];

  return (
    <React.Fragment>
      {items.map((item, index) => (
        <React.Fragment key={index}>
          <p>{item}</p>
        </React.Fragment>
      ))}
    </React.Fragment>
  );
}
```

如果直接用 `<>...</>`：

```jsx
{items.map((item, index) => (
  <>  // ❌ 不能在这里使用 key
    <p>{item}</p>
  </>
))}
```

✅ **使用 `React.Fragment` 显式写出 `key`，可以避免 React 的 `key` 警告。**

---

### 7. 什么时候不用 `React.Fragment`？

- **只有一个根元素时**：如果 `render()` 只返回单个元素，则 **不需要 `Fragment`**。
    
    ```jsx
    function MyComponent() {
      return <h1>Hello World</h1>; // 不需要 Fragment
    }
    ```
    
- **需要添加 `className`、`style` 或 `data-*` 属性时**：
    - `React.Fragment` 不能像 `<div>` 一样使用 `className` 或 `id`：
        
        ```jsx
        <React.Fragment className="box"> // ❌ 无效，Fragment 不支持 className
          <h1>Hello</h1>
          <p>World</p>
        </React.Fragment>
        ```
        
    - **解决方案**：使用 `div` 或 `<span>`，如果一定要用 `Fragment`，只能用 `key`。

---

### 8. `React.Fragment` vs `<>...</>` 的区别

| |`React.Fragment`|`<>...</>` (短语法)|
|---|---|---|
|**是否支持 `key`**|✅ 是|❌ 否|
|**是否支持 `className`**|❌ 否|❌ 否|
|**是否支持 `style`**|❌ 否|❌ 否|
|**语法简洁性**|需要写 `React.Fragment`|✅ 更简洁|
|**适用场景**|适用于 `map()` 需要 `key`|适用于简单 JSX 结构|

✅ **一般建议**：

- **如果需要 `key`，用 `React.Fragment`。**
- **如果不需要 `key`，用 `<>...</>` 更简洁。**

---

### 9. 总结

- `React.Fragment` 允许在 `render()` 方法返回**多个元素**，不会生成额外的 DOM 结构。
- 适用于：
    - 避免 `div` 影响布局。
    - `table`、`ul` 等严格的 HTML 结构。
    - 提高渲染性能，减少 DOM 计算。
- **短语法 `<>...</>` 更简洁**，但不能使用 `key`。
- **最佳实践**：如果 `map()` 需要 `key`，用 `React.Fragment`；其他情况用 `<>...</>`。

🚀 这样可以让你的 React 代码更清晰、性能更高！

## 16. React如何获取组件对应的DOM元素？

在 React 中，可以通过 **`ref`（引用）** 获取组件对应的 DOM 元素。React 提供了多种方式来获取 DOM，具体方法如下：

---

### **1. 使用 `useRef`（推荐方式，适用于函数组件）**

在 **函数组件** 中，我们可以使用 `useRef` 获取 DOM 元素。

#### **示例：获取 `input` DOM**
```jsx
import React, { useRef } from "react";

function InputFocus() {
  const inputRef = useRef(null); // 创建 ref

  const focusInput = () => {
    inputRef.current.focus(); // 获取 DOM 元素并聚焦
  };

  return (
    <div>
      <input ref={inputRef} type="text" placeholder="输入点什么..." />
      <button onClick={focusInput}>点击聚焦输入框</button>
    </div>
  );
}

export default InputFocus;
```
#### **解释**

- `useRef(null)` **创建一个 `ref` 对象**。
- `ref` 绑定到 `input` 元素上 (`ref={inputRef}`)。
- `inputRef.current` **指向真实的 DOM 元素**。
- `inputRef.current.focus()` **调用 `focus()` 方法，使 `input` 聚焦**。

✅ **适用于**：
- **函数组件**（推荐）。
- **获取 DOM 元素（input, div, button 等）**。
- **管理 DOM 交互（focus, scroll, class 操作）**。

---

### **2. 使用 `createRef`（适用于类组件）**

在 **类组件** 中，React 提供 `React.createRef()` 作为获取 DOM 的方法。

**示例：类组件获取 DOM**
```jsx
import React, { Component, createRef } from "react";

class InputFocus extends Component {
  constructor(props) {
    super(props);
    this.inputRef = createRef(); // 创建 ref
  }

  focusInput = () => {
    this.inputRef.current.focus(); // 获取 DOM 并聚焦
  };

  render() {
    return (
      <div>
        <input ref={this.inputRef} type="text" placeholder="输入点什么..." />
        <button onClick={this.focusInput}>点击聚焦输入框</button>
      </div>
    );
  }
}

export default InputFocus;
```

#### **解释**

- `this.inputRef = React.createRef();` **创建 ref**。
- `<input ref={this.inputRef} />` **绑定到 DOM**。
- `this.inputRef.current.focus();` **操作 DOM**。

✅ **适用于**：

- **类组件**（推荐）。
- **获取 DOM 节点**。

---

### **3. `callback ref`（函数形式）**

另一种方式是使用**回调 `ref`**（`callback ref`），可以直接操作 `ref` 而不使用 `useRef` 或 `createRef`。

**示例：回调 `ref` 获取 `input`**
```jsx
class InputFocus extends React.Component {
  focusInput = () => {
    this.inputRef.focus(); // 直接访问 DOM
  };

  render() {
    return (
      <div>
        <input ref={(el) => (this.inputRef = el)} type="text" />
        <button onClick={this.focusInput}>点击聚焦输入框</button>
      </div>
    );
  }
}
```

#### **解释**

- `ref={(el) => (this.inputRef = el)}` 直接把 DOM 赋值给 `this.inputRef`。
- `this.inputRef.focus()` 直接操作 DOM。

✅ **适用于**：

- **在 `ref` 需要动态变化时**（例如：条件渲染）。
- **适用于类组件**。

---

### **4. 获取组件的 DOM（Forward Ref）**

**普通 `ref` 不能直接用于函数组件**，因为函数组件**没有实例**。如果想要让 `ref` 透传到子组件的 DOM，可以使用 `forwardRef`。

#### **示例：父组件获取子组件的 `input`**

```jsx
import React, { forwardRef, useRef } from "react";

// 子组件
const MyInput = forwardRef((props, ref) => {
  return <input ref={ref} type="text" placeholder="输入..." />;
});

// 父组件
function Parent() {
  const inputRef = useRef(null);

  const focusInput = () => {
    inputRef.current.focus(); // 获取子组件的 input
  };

  return (
    <div>
      <MyInput ref={inputRef} />
      <button onClick={focusInput}>聚焦子组件的 input</button>
    </div>
  );
}

export default Parent;
```

#### **解释**

- `forwardRef` 允许 `ref` 透传到 **函数组件** 内部。
- `inputRef.current.focus();` 获取 `MyInput` 组件内部的 `input`。

✅ **适用于**：

- **父组件需要获取子组件的 DOM 元素**。
- **解决 `ref` 不能直接用于函数组件的问题**。

---

### **5. `useImperativeHandle`（自定义 `ref`）**

有时候，我们希望**对子组件暴露更具体的 API**，可以用 `useImperativeHandle` **自定义 `ref`**。

#### **示例：父组件调用子组件的方法**

```jsx
import React, { useRef, useImperativeHandle, forwardRef } from "react";

// 子组件
const MyInput = forwardRef((props, ref) => {
  const inputRef = useRef();

  useImperativeHandle(ref, () => ({
    focus: () => inputRef.current.focus(), // 自定义暴露的方法
    clear: () => (inputRef.current.value = ""), // 自定义清除 input
  }));

  return <input ref={inputRef} type="text" />;
});

// 父组件
function Parent() {
  const inputRef = useRef();

  return (
    <div>
      <MyInput ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>聚焦</button>
      <button onClick={() => inputRef.current.clear()}>清空</button>
    </div>
  );
}

export default Parent;
```

#### **解释**

- `useImperativeHandle(ref, () => ({ focus, clear }))` 自定义暴露给父组件的方法。
- 父组件可以 `inputRef.current.focus()` 或 `inputRef.current.clear()` 调用子组件的方法。

✅ **适用于**：

- **希望子组件只暴露特定的方法**，而不是整个 DOM。

---

### **6. `document.querySelector`（直接查找 DOM，不推荐）**

虽然可以使用 `document.querySelector()` 直接查找 DOM，但在 React 中**不推荐**这样做，因为它绕过了 React 的虚拟 DOM 机制，可能导致不一致的 UI。

```jsx
function MyComponent() {
  const handleClick = () => {
    document.querySelector("input").focus(); // 获取 DOM
  };

  return (
    <div>
      <input type="text" />
      <button onClick={handleClick}>点击聚焦</button>
    </div>
  );
}
```

**问题：**

- 直接操作 DOM 可能导致 React 的状态失效。
- 在动态渲染组件时可能导致 `querySelector` 找不到元素。

✅ **推荐使用 `ref` 代替 `querySelector`**。

---

### **7. 总结**

| 方法                         | 适用组件 | 适用场景                       | 推荐程度    |
| -------------------------- | ---- | -------------------------- | ------- |
| `useRef()`                 | 函数组件 | 访问 DOM，获取 `input`, `div` 等 | ✅✅✅（推荐） |
| `createRef()`              | 类组件  | 访问 DOM，类似 `useRef`         | ✅✅      |
| 回调 `ref`                   | 类组件  | `ref` 需要动态变化时              | ✅       |
| `forwardRef()`             | 函数组件 | 让父组件访问子组件的 `ref`           | ✅✅✅（推荐） |
| `useImperativeHandle()`    | 函数组件 | 让子组件暴露自定义方法                | ✅✅✅（推荐） |
| `document.querySelector()` | 任何组件 | 直接操作 DOM                   | ❌（不推荐）  |

✅ **最佳实践**

- **函数组件**：用 `useRef()` 获取 DOM。
- **类组件**：用 `createRef()`。
- **子组件 DOM 透传**：用 `forwardRef()`。
- **子组件暴露方法**：用 `useImperativeHandle()`。

React 的 `ref` 机制可以安全地获取 DOM，避免不必要的手动查询，提高代码可维护性！ 🚀　　　  

## 17. React中可以在render访问refs吗？为什么？
不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段： ![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98a52a67abd14d8cb2ba1fc00c0662a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)
在 React 中，虽然技术上你可以在 `render` 方法中访问 `refs`（例如通过 `this.refs`），但实际上不推荐这么做。原因主要有以下几点：

1. **初始渲染时可能还未创建**：在组件第一次渲染时，`refs` 还没有被赋值，因此直接访问可能会得到 `null` 或 `undefined`。
    
2. **render 应该是纯函数**：`render` 方法的设计理念是纯粹的，即不依赖或修改外部状态。使用 `refs` 可能会引入副作用，违反这一原则。
    
3. **最佳实践**：React 推荐在生命周期方法（如 `componentDidMount` 或 `componentDidUpdate`）中访问 `refs`，确保它们已经正确初始化，并且在操作 DOM 时更加安全和可靠。
    

因此，尽管在某些情况下你可能能在 `render` 中访问到 `refs`，但为了保持代码的可预测性和符合 React 的设计理念，最好将对 `refs` 的操作放在合适的生命周期方法中。
## 18. 对React的插槽(Portals)的理解，如何使用，有哪些使用场景

React Portals（插槽）是一种在 DOM 结构上“跳出”父组件层级限制，将组件的子节点渲染到指定 DOM 节点的技术。下面详细解释它的概念、使用方法和适用场景：

### 1. 概念理解

- **什么是 Portals？**  
    Portals 允许你将子组件挂载到 DOM 树中一个与父组件层级无关的位置。这意味着，即使组件逻辑和状态管理都在父组件中，但它们的 DOM 结构可以放在页面的其他位置。
    
- **事件冒泡**  
    值得注意的是，尽管 Portals 使得 DOM 结构发生了改变，但 React 依然会保持事件的冒泡行为。也就是说，事件仍然会从 Portal 内部的元素向上冒泡到父组件。
    

### 2. 如何使用 Portals

使用 Portals 非常简单，只需要使用 `ReactDOM.createPortal` 方法。其基本用法如下：

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

class Modal extends React.Component {
  render() {
    // 假设页面中有一个 id 为 'modal-root' 的 DOM 节点
    return ReactDOM.createPortal(
      <div className="modal">
        {this.props.children}
      </div>,
      document.getElementById('modal-root')
    );
  }
}
```

在上面的代码中：

- **第一个参数** 是要渲染的 React 元素（比如模态框的内容）。
- **第二个参数** 是目标 DOM 节点，该节点可以在整个应用之外，例如在 `index.html` 中单独定义一个 `<div id="modal-root"></div>`。

### 3. 使用场景

Portals 的特性使其在以下场景中非常有用：

- **模态框/对话框**  
    模态框通常需要在页面的最外层展示，以避免被父容器的 CSS 属性（如 `overflow: hidden`）遮挡。通过 Portals，可以确保模态框不受父组件布局的限制。
    
- **通知/提示信息**  
    比如全局提示、Toast 通知等，这些通常需要在页面的固定位置展示，而不受组件嵌套的影响。
    
- **工具提示（Tooltip）和下拉菜单**  
    当这些组件需要脱离正常的 DOM 流布局以避免遮挡或溢出问题时，可以利用 Portals 渲染到 body 或其他特定的容器中。
    
- **全局加载器或遮罩层**  
    当需要全屏展示一个加载状态或遮罩层时，使用 Portals 可以确保其覆盖整个页面，而不是局限于某个父容器的范围。
    

### 总结

React Portals 让我们可以在不破坏组件逻辑层次的前提下，灵活地控制 DOM 渲染位置，非常适合处理模态框、通知、工具提示等需要全局覆盖或者脱离父组件限制的场景。通过 `ReactDOM.createPortal` 方法，可以轻松将组件内容挂载到任意指定的 DOM 节点，同时保持事件系统的连贯性。
## 19. 在React中如何避免不必要的render？

React 基于虚拟 DOM 和高效 Diff 算法的完美配合，实现了对 DOM 最小粒度的更新。大多数情况下，React 对 DOM 的渲染效率足以业务日常。但在个别复杂业务场景下，性能问题依然会困扰我们。此时需要采取一些措施来提升运行性能，其很重要的一个方向，就是避免不必要的渲染（Render）。这里提下优化的点：

下面列举几种常用方法：

1. **使用 PureComponent 或 React.memo**
    
    - **PureComponent**：对于类组件，可以继承 `React.PureComponent`，它会自动进行浅比较（shallow compare），从而只在 props 或 state 发生改变时才触发 render。
    - **React.memo**：对于函数组件，可以使用 `React.memo` 包装组件，类似于 PureComponent，它会对组件的 props 进行浅比较，从而避免不必要的渲染。
2. **合理使用 shouldComponentUpdate**  
    对于类组件，可以手动实现 `shouldComponentUpdate` 方法，根据实际需求精细控制组件是否需要更新。这样可以避免一些因父组件更新而引起的无意义渲染。
    
3. **使用 useMemo 和 useCallback**
    
    - **useMemo**：用来缓存计算结果，只有在依赖变化时才重新计算，从而减少不必要的重新计算，避免传递新的引用给子组件。
    - **useCallback**：用来缓存函数引用，确保在组件重新渲染时不创建新的函数对象，防止子组件因函数引用改变而重新渲染。
4. **拆分组件和提升状态**
    
    - **拆分组件**：将复杂组件拆分为多个小组件，确保只有状态或 props 变化的部分才会重新渲染。
    - **提升状态**：合理规划状态的分布，避免不必要的全局状态更新导致整个组件树的重新渲染。
5. **避免不必要的状态更新**
    
    - 确保只有在真正需要更新时才调用 `setState` 或更新 state，避免在 render 中直接进行状态修改。
    - 使用不可变数据结构，确保通过浅比较即可判断数据是否发生了变化。
6. **合适的 key 使用**  
    在列表渲染时，确保使用唯一且稳定的 `key` 值，帮助 React 更好地复用组件，避免因重新渲染而带来的性能问题。
    

通过以上方法，可以有效减少 React 中不必要的渲染，提高应用性能。
## 20. 对 React-Intl 的理解，它的工作原理？

React-intl是雅虎的语言国际化开源项目FormatJS的一部分，通过其提供的组件和API可以与ReactJS绑定。

React-intl提供了两种使用方法，一种是引用React组件，另一种是直接调取API，官方更加推荐在React项目中使用前者，只有在无法使用React组件的地方，才应该调用框架提供的API。它提供了一系列的React组件，包括数字格式化、字符串格式化、日期格式化等。

在React-intl中，可以配置不同的语言包，他的工作原理就是根据需要，在语言包之间进行切换。

## 21. 对 React context 的理解

在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单项数据流在某些场景中并不适用。单纯一对的父子组件传递并无问题，但要是组件之间层层依赖深入，props就需要层层传递显然，这样做太繁琐了。

Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。

可以把context当做是特定一个组件树内共享的store，用来做数据传递。**简单说就是，当你不想在组件树中通过逐层传递props或者state的方式来传递数据时，可以使用Context来实现跨层级的组件数据传递。**

JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数。

假如以JS的作用域链作为类比，React组件提供的Context对象其实就好比一个提供给子组件访问的作用域，而 Context对象的属性可以看成作用域上的活动对象。由于组件 的 Context 由其父节点链上所有组件通 过 getChildContext（）返回的Context对象组合而成，所以，组件通过Context是可以访问到其父组件链上所有节点组件提供的Context的属性。

## 22. 为什么React并不推荐优先考虑使用Context？

- Context目前还处于实验阶段，可能会在后面的发行版本中有很大的变化，事实上这种情况已经发生了，所以为了避免给今后升级带来大的影响和麻烦，不建议在app中使用context。
- 尽管不建议在app中使用context，但是独有组件而言，由于影响范围小于app，如果可以做到高内聚，不破坏组件树之间的依赖关系，可以考虑使用context
- 对于组件之间的数据通信或者状态管理，有效使用props或者state解决，然后再考虑使用第三方的成熟库进行解决，以上的方法都不是最佳的方案的时候，在考虑context。
- context的更新需要通过setState()触发，但是这并不是很可靠的，Context支持跨组件的访问，但是如果中间的子组件通过一些方法不影响更新，比如 shouldComponentUpdate() 返回false 那么不能保证Context的更新一定可以使用Context的子组件，因此，Context的可靠性需要关注

## 23. React中什么是受控组件和非控组件？

**（1）受控组件** 在使用表单来收集用户输入时，例如`<input><select><textearea>`等元素都要绑定一个change事件，当表单的状态发生变化，就会触发onChange事件，更新组件的state。这种组件在React中被称为**受控组件**，在受控组件中，组件渲染出的状态与它的value或checked属性相对应，react通过这种方式消除了组件的局部状态，使整个状态可控。react官方推荐使用受控表单组件。

受控组件更新state的流程：

- 可以通过初始state中设置表单的默认值
- 每当表单的值发生变化时，调用onChange事件处理器
- 事件处理器通过事件对象e拿到改变后的状态，并更新组件的state
- 一旦通过setState方法更新state，就会触发视图的重新渲染，完成表单组件的更新

**受控组件缺陷：** 表单元素的值都是由React组件进行管理，当有多个输入框，或者多个这种组件时，如果想同时获取到全部的值就必须每个都要编写事件处理函数，这会让代码看着很臃肿，所以为了解决这种情况，出现了非受控组件。

**（2）非受控组件** 如果一个表单组件没有value props（单选和复选按钮对应的是checked props）时，就可以称为非受控组件。在非受控组件中，可以使用一个ref来从DOM获得表单值。而不是为每个状态更新编写一个事件处理程序。

React官方的解释：

> 要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以使用 ref来从 DOM 节点中获取表单数据。 因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。


## 24. React中refs的作用是什么？有哪些应用场景？

Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。Refs 应该谨慎使用，如下场景使用 Refs 比较适合：

- 处理焦点、文本选择或者媒体的控制
- 触发必要的动画
- 集成第三方 DOM 库

Refs 是使用 `React.createRef()` 方法创建的，他通过 `ref` 属性附加到 React 元素上。要在整个组件中使用 Refs，需要将 `ref` 在构造函数中分配给其实例属性：
```js
class MyComponent extends React.Component {
  constructor(props) {
    super(props)
    this.myRef = React.createRef()
  }
  render() {
    return <div ref={this.myRef} />
  }
}
```

由于函数组件没有实例，因此不能在函数组件上直接使用 `ref`：

```js
function MyFunctionalComponent() {
  return <input />;
}
class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.textInput = React.createRef();
  }
  render() {
    // 这将不会工作！
    return (
      <MyFunctionalComponent ref={this.textInput} />
    );
  }
}
```

但可以通过闭合的帮助在函数组件内部进行使用 Refs：
```js
function CustomTextInput(props) {
  // 这里必须声明 textInput，这样 ref 回调才可以引用它
  let textInput = null;
  function handleClick() {
    textInput.focus();
  }
  return (
    <div>
      <input
        type="text"
        ref={(input) => { textInput = input; }} />
      <input
        type="button"
        value="Focus the text input"
        onClick={handleClick}
      />
    </div>
  );  
}
```

**注意：**

- 不应该过度的使用 Refs
- `ref` 的返回值取决于节点的类型：
    - 当 `ref` 属性被用于一个普通的 HTML 元素时，`React.createRef()` 将接收底层 DOM 元素作为他的 `current` 属性以创建 `ref`。
    - 当 `ref` 属性被用于一个自定义的类组件时，`ref` 对象将接收该组件已挂载的实例作为他的 `current`。
- 当在父组件中需要访问子组件中的 `ref` 时可使用传递 Refs 或回调 Refs。

## 26. React组件的构造函数有什么作用？它是必须的吗？

构造函数主要用于两个目的：

- 通过将对象分配给this.state来初始化本地状态
- 将事件处理程序方法绑定到实例上

所以，当在React class中需要设置state的初始值或者绑定事件时，需要加上构造函数，官方Demo：

```js
class LikeButton extends React.Component {
  constructor() {
    super();
    this.state = {
      liked: false
    };
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    this.setState({liked: !this.state.liked});
  }
  render() {
    const text = this.state.liked ? 'liked' : 'haven\'t liked';
    return (
      <div onClick={this.handleClick}>
        You {text} this. Click to toggle.
      </div>
    );
  }
}
ReactDOM.render(
  <LikeButton />,
  document.getElementById('example')
);
```

构造函数用来新建父类的this对象；子类必须在constructor方法中调用super方法；否则新建实例时会报错；因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法；子类就得不到this对象。

**注意：**

- constructor () 必须配上 super(), 如果要在constructor 内部使用 this.props 就要 传入props , 否则不用
- JavaScript中的 bind 每次都会返回一个新的函数, 为了性能等考虑, 尽量在constructor中绑定事件

## 27. React.forwardRef是什么？它有什么作用？

React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。这种技术并不常见，但在以下两种场景中特别有用：

- 转发 refs 到 DOM 组件
- 在高阶组件中转发 refs

## 28. 类组件与函数组件有什么异同？

**相同点：** 组件是 React 可复用的最小代码片段，它们会返回要在页面中渲染的 React 元素。也正因为组件是 React 的最小编码单位，所以无论是函数组件还是类组件，在使用方式和最终呈现效果上都是完全一致的。

我们甚至可以将一个类组件改写成函数组件，或者把函数组件改写成一个类组件（虽然并不推荐这种重构行为）。从使用者的角度而言，很难从使用体验上区分两者，而且在现代浏览器中，闭包和类的性能只在极端场景下才会有明显的差别。所以，基本可认为两者作为组件是完全一致的。

**不同点：**

- 它们在开发时的心智模型上却存在巨大的差异。类组件是基于面向对象编程的，它主打的是继承、生命周期等核心概念；而函数组件内核是函数式编程，主打的是 immutable、没有副作用、引用透明等特点。
- 之前，在使用场景上，如果存在需要使用生命周期的组件，那么主推类组件；设计模式上，如果需要使用继承，那么主推类组件。但现在由于 React Hooks 的推出，生命周期概念的淡出，函数组件可以完全取代类组件。其次继承并不是组件最佳的设计模式，官方更推崇“组合优于继承”的设计概念，所以类组件在这方面的优势也在淡出。
- 性能优化上，类组件主要依靠 shouldComponentUpdate 阻断渲染来提升性能，而函数组件依靠 React.memo 缓存渲染结果来提升性能。
- 从上手程度而言，类组件更容易上手，从未来趋势上看，由于React Hooks 的推出，函数组件成了社区未来主推的方案。
- 类组件在未来时间切片与并发模式中，由于生命周期带来的复杂度，并不易于优化。而函数组件本身轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展。
