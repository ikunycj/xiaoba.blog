## 1.HTTPS为什么比HTTP更安全？他们秘钥是怎么签署的？使用的什么加密算法？
### **为什么 HTTPS 比 HTTP 更安全？**

HTTPS（HyperText Transfer Protocol Secure）比 HTTP（HyperText Transfer Protocol）更安全，主要是因为它在 HTTP 的基础上增加了 **TLS/SSL（Transport Layer Security / Secure Sockets Layer）** 加密协议，使数据传输更加安全。HTTPS 的主要安全性来源如下：

1. **数据加密（Encryption）**
    - 通过 **对称加密** 确保数据在客户端和服务器之间传输时无法被窃听，即使被拦截也无法解密。
    - 防止**中间人攻击（MITM，Man-In-The-Middle Attack）**。

2. **数据完整性（Integrity）**
    - 通过 **消息认证码（MAC）或哈希算法** 确保数据在传输过程中没有被篡改。

3. **身份认证（Authentication）**
    - 通过 **数字证书（SSL 证书）** 确保服务器的身份真实，防止钓鱼网站和伪造服务器。

---

### **HTTPS 的密钥签署过程**

HTTPS 的安全性依赖于 TLS/SSL 证书，它的密钥签署主要包括以下步骤：

#### **1. 证书申请与颁发**

- 网站所有者向 **证书颁发机构（CA，Certificate Authority）** 申请 SSL/TLS 证书。
- CA 机构会验证网站的身份后，使用 **CA 的私钥（Private Key）** 对网站的公钥（Public Key）进行签名，颁发证书。

#### **2. TLS 握手过程（密钥协商）**

在客户端（浏览器）和服务器之间的 HTTPS 连接建立过程中，会进行 **TLS 握手（TLS Handshake）**，这个过程涉及公钥和对称密钥的协商：

1. **客户端 Hello**
    - 客户端（浏览器）发送一个请求，包含支持的 **TLS 版本**、加密算法列表（Cipher Suites）、随机数（Client Random）等信息。

2. **服务器 Hello**
    - 服务器响应，选择**TLS 版本**和**加密算法**，同时发送 **服务器证书**（包含 CA 签名的公钥）和一个随机数（Server Random）。

3. **密钥交换（Key Exchange）**
    - 客户端验证服务器的证书是否可信（检查 CA 签名）。
    - 然后，使用服务器的公钥加密一个**新的对称密钥**（Pre-Master Key），并发送给服务器。
    - 服务器使用自己的私钥解密，获得对称密钥。

4. **对称加密通信**
    - 之后，双方使用协商好的**对称密钥**加密通信，提高效率。

---

### **HTTPS 使用的加密算法**

HTTPS 使用 **混合加密机制**，结合 **对称加密** 和 **非对称加密** 进行安全通信。

#### **1. 非对称加密（Asymmetric Encryption）**：用于密钥交换
- **RSA（Rivest-Shamir-Adleman）**
- **ECDH（Elliptic Curve Diffie-Hellman）**
- **ECDSA（Elliptic Curve Digital Signature Algorithm）**

非对称加密的作用：

- **客户端生成 Pre-Master Key，使用服务器的公钥加密**，服务器用私钥解密。
- **服务器证书的签名和验证**，确保身份真实性。

#### **2. 对称加密（Symmetric Encryption）**：用于数据传输

一旦 TLS 握手完成，通信使用 **对称加密算法**，因为它比非对称加密快很多：

- **AES（Advanced Encryption Standard）**：常用 128-bit、192-bit、256-bit
- **ChaCha20**（主要用于移动设备）

对称加密的作用：

- **所有的数据传输都使用同一个对称密钥进行加密和解密**，确保高效、安全的通信。

#### **3. 哈希算法（Hashing）**：用于数据完整性验证

- **SHA-256 / SHA-384 / SHA-512**（Secure Hash Algorithm）
- **HMAC（Hash-based Message Authentication Code）**
- **MD5（已被淘汰，不安全）**

哈希算法的作用：

- **确保数据完整性**，如果数据被篡改，哈希值将不匹配。

---

### **总结**

- **HTTPS 比 HTTP 更安全**，因为它采用 TLS/SSL 加密，防止窃听、篡改和身份伪造。
- **HTTPS 使用非对称加密进行密钥交换**（如 RSA/ECDH），然后使用**对称加密（AES/ChaCha20）** 进行数据传输，提高效率。
- **服务器证书由 CA 机构签署，确保服务器身份真实**，防止钓鱼攻击。
- **HTTPS 还采用哈希算法（SHA-256）** 确保数据完整性。

这种 **混合加密** 方式既保证了安全性，又提升了性能，是现代网络安全的核心。

## 2.服务端推送有了解吗？说一下websocket和sse的优缺点？传输的数据格式是什么？知道`server push`吗？
### 服务端推送

服务端推送（Server Push）是一种服务器主动向客户端发送数据的技术，常用于实时更新、通知等场景。常见的实现方式有 WebSocket 和 Server-Sent Events (SSE)。

### WebSocket

**优点**：
1. **全双工通信**：支持客户端和服务器双向实时通信。
2. **低延迟**：适合实时性要求高的场景，如在线游戏、聊天应用。
3. **高效**：基于二进制帧，数据量小，传输效率高。

**缺点**：
1. **复杂性**：实现和维护较为复杂。
2. **兼容性**：部分旧浏览器或网络环境可能不支持。
3. **资源消耗**：长时间连接可能增加服务器负担。

**传输数据格式**：
- 支持文本和二进制数据。

### Server-Sent Events (SSE)

**优点**：
1. **简单易用**：基于 HTTP 协议，实现简单。
2. **自动重连**：内置支持断线重连。
3. **文本格式**：适合文本数据传输，如实时日志、通知。

**缺点**：
1. **单向通信**：仅支持服务器向客户端推送数据。
2. **兼容性**：部分浏览器可能不支持。
3. **数据格式限制**：仅支持**文本数据**。

**传输数据格式**：
- 仅支持文本数据，通常为 `text/event-stream` 格式。

### Server Push

**Server Push** 是 HTTP/2 的一项特性，允许服务器在客户端请求前主动推送资源。常用于优化网页加载性能，提前推送 CSS、JavaScript 等资源。

**优点**：
1. **性能优化**：减少客户端请求，提升加载速度。
2. **减少延迟**：提前推送资源，降低页面渲染时间。

**缺点**：
1. **资源浪费**：可能推送客户端已缓存或不需的资源。
2. **复杂性**：需合理配置推送策略，避免过度推送。

### 总结对比

| 特性            | SSE                      | WebSocket            | HTTP/2 Server Push |
| ------------- | ------------------------ | -------------------- | ------------------ |
| **通信方向**      | 服务器 → 客户端（单向）            | 客户端 ⇄ 服务器（双向）        | 服务器 → 客户端（单向）      |
| **是否基于 HTTP** | 是（HTTP/1.1）              | 仅握手时使用 HTTP，后续基于 TCP | 是（仅 HTTP/2）        |
| **是否支持双向通信**  | 否                        | 是                    | 否                  |
| **是否支持自动重连**  | 是                        | 需要手动实现               | 否                  |
| **数据格式**      | 纯文本（`text/event-stream`） | 任意格式（文本、二进制）         | 任意格式（静态资源）         |
| **主要用途**      | 服务器推送实时数据                | 实时双向通信（如聊天）          | 资源预加载              |
| **适用场景**      | 通知、状态更新                  | 聊天、游戏、协作应用           | 静态资源优化             |


## 3.http0.9/1.0/1.1/2.0/3.0的区别
HTTP（超文本传输协议）是 Web 上进行通信的核心协议。随着技术的发展，HTTP 版本不断演进，以适应更高效、更安全的通信需求。HTTP 0.9、1.0、1.1、2.0 和 3.0 每个版本都引入了新的特性和改进。以下是它们的主要区别：

### **HTTP/0.9**

HTTP/0.9 是最早的 HTTP 版本，于 1991 年由 **Tim Berners-Lee** 发布。它非常简单，只支持 **GET 请求**，没有请求头、响应头和其他任何复杂功能。具体特点包括：

- **仅支持 GET 请求**，没有 POST 或其他 HTTP 方法。
- **没有请求头和响应头**：所有的信息都在请求和响应的正文中传输。
- **没有状态管理**，每次请求都视为独立的，不能识别之前的请求。
- **无连接**：每个请求和响应都是独立的，不存在连接复用。

### **HTTP/1.0**

HTTP/1.0 于 1996 年发布，是第一个广泛使用的 HTTP 版本。它对 HTTP/0.9 做了重要的改进，尤其是在 **请求/响应头** 和 **状态管理** 方面。

- **请求/响应头**：引入了请求头和响应头，使客户端与服务器之间的通信更为灵活，能够传递更多的元数据（如 `User-Agent`、`Content-Type` 等）。
- **支持更多的 HTTP 方法**：如 **POST** 和 **HEAD** 等。
- **短连接**：每次请求和响应都通过一个新的 TCP 连接进行传输，传输完成后连接断开。
- **无多路复用**：每个请求都需要独立的 TCP 连接，导致了 **队头阻塞**（Head-of-Line Blocking）问题。

### **HTTP/1.1**

HTTP/1.1 于 1997 年发布，成为 Web 的标准协议，直到今天大部分 Web 通信仍使用它。与 HTTP/1.0 相比，HTTP/1.1 引入了许多优化，使其性能和灵活性大大提高。

- **持久连接（Keep-Alive）**：允许多个请求共享同一个 TCP 连接，减少了建立连接的开销，改善了性能。
- **管道化（Pipelining）**：支持在同一连接上并发发送多个请求，服务器响应时按顺序返回结果，减少了等待时间。
- **更多的 HTTP 方法**：如 **PUT**、**DELETE**、**OPTIONS** 等。
- **请求头和响应头的优化**：例如引入了 **分块传输编码（Chunked Transfer Encoding）**，支持逐步传输大文件。
- **缓存控制**：引入了 **缓存控制机制**，允许客户端和服务器更好地管理缓存（例如 `Cache-Control` 头部）。
- **改进的错误状态码**：增加了更多的状态码（如 404、503）以支持更丰富的错误处理。

### **HTTP/2.0**

HTTP/2.0 于 2015 年发布，它的主要目标是提高性能，解决 HTTP/1.x 中的瓶颈，尤其是多连接和请求延迟的问题。HTTP/2.0 做了以下改进：

- **二进制分帧（Binary Framing）**：与 HTTP/1.x 的文本协议不同，HTTP/2 使用二进制格式对数据进行分帧，使得解析效率更高。
- **多路复用（Multiplexing）**：允许多个请求在同一个 TCP 连接上并行进行，不再需要为每个请求建立单独的连接，解决了 HTTP/1.x 中的 **队头阻塞** 问题。
- **头部压缩（HPACK）**：采用 **HPACK** 算法压缩请求头和响应头，减少了带宽的使用。
- **服务器推送（Server Push）**：服务器可以主动推送资源到客户端，减少了客户端发起的请求次数。
- **流量控制**：支持对流的优先级和大小进行控制，优化资源的分配。

### **HTTP/3.0**

HTTP/3.0 于 2020 年开始推广，基于 **QUIC（Quick UDP Internet Connections）** 协议，它是由 Google 开发的，采用 UDP 协议而非 TCP。HTTP/3.0 相较于 HTTP/2.0 引入了以下改进：

- **基于 QUIC 协议**：使用 **UDP** 而非 TCP 作为传输层协议。QUIC 解决了 TCP 连接建立慢、丢包重传慢等问题，支持更快的连接和更低的延迟。
- **多路复用**：和 HTTP/2 一样，HTTP/3 支持在同一个连接上传输多个流，但由于基于 QUIC，HTTP/3 在遇到丢包时的恢复效率更高，避免了 HTTP/2 中的一个常见问题（丢包导致所有流阻塞）。
- **改进的加密**：QUIC 协议将 TLS 加密集成在内，使得加密和数据传输更紧密，减少了延迟。
- **无队头阻塞**：HTTP/3 彻底解决了 **队头阻塞** 问题，特别是当存在丢包时，其他流的传输不会受到影响。
- **连接迁移**：QUIC 支持连接迁移，可以在不同的网络环境（如 Wi-Fi 到移动网络）之间无缝切换。

### **总结**

| 特性           | HTTP/0.9 | HTTP/1.0           | HTTP/1.1                 | HTTP/2.0      | HTTP/3.0       |
| ------------ | -------- | ------------------ | ------------------------ | ------------- | -------------- |
| **协议版本发布年份** | 1991     | 1996               | 1997                     | 2015          | 2020           |
| **请求方法**     | 仅支持 GET  | 支持 GET, POST, HEAD | 支持多种方法（GET, POST, PUT 等） | 支持多种方法        | 支持多种方法         |
| **连接管理**     | 无连接      | 短连接（每个请求建立新连接）     | 持久连接（Keep-Alive）         | 多路复用（同一连接多请求） | 基于 QUIC，支持连接迁移 |
| **请求/响应头**   | 无        | 支持请求/响应头           | 支持请求/响应头                 | 支持并压缩请求/响应头   | 支持并压缩请求/响应头    |
| **数据传输格式**   | 文本格式     | 文本格式               | 文本格式                     | 二进制帧格式        | 基于 QUIC 的二进制格式 |
| **多路复用**     | 不支持      | 不支持                | 支持（管道化）                  | 支持多路复用        | 支持多路复用         |
| **服务器推送**    | 不支持      | 不支持                | 不支持                      | 支持服务器推送       | 支持服务器推送        |
| **加密**       | 无        | 无                  | 无（但可以使用 SSL）             | 支持（基于 TLS）    | 支持（集成 TLS）     |

每个 HTTP 版本都在不断地优化性能、安全性和可扩展性，HTTP/3 作为最新的版本，尤其通过采用 QUIC 协议，为提高 Web 性能和降低延迟做出了重要贡献。

## 4.说一下客户端缓存，服务端缓存，HTTP缓存，浏览器缓存各自的特点。
**缓存机制** 在 Web 性能优化中是一个至关重要的概念，目的是减少数据的重复加载，提高请求响应速度，降低带宽消耗。缓存通常分为客户端缓存、服务器端缓存、HTTP 缓存和浏览器缓存。每种缓存机制有其独特的作用和特点。

### **1. 客户端缓存**

**客户端缓存** 是指存储在用户设备上的缓存数据。它通常由客户端的应用程序（如浏览器、移动应用等）管理，能够缓存多种类型的数据，如网页内容、图片、文件、JSON 数据等。

- **存储位置**：存储在客户端的硬盘或内存中，例如浏览器缓存、应用缓存等。
- **数据更新方式**：客户端缓存通常有过期时间，或者通过某种机制（如 `ETag`、`Last-Modified`）来判断缓存是否过期并决定是否更新。
- **优点**：通过减少对服务器的请求，能显著提高页面加载速度，减少带宽消耗。
- **缺点**：客户端缓存需要有效的缓存策略管理。若缓存数据不更新或缓存管理不当，可能导致客户端展示过时的数据。

### **2. 服务器端缓存**

**服务器端缓存** 是指服务器存储的数据缓存，通常用于加速频繁访问的资源请求，减少服务器的计算和数据库查询负担。

- **存储位置**：通常存储在内存中，如 Redis、Memcached，或者磁盘中（例如 HTTP 缓存）。
- **数据更新方式**：服务器缓存可能会基于过期时间、缓存策略（如 LRU，最少使用策略）或请求频率来更新数据。
- **优点**：通过缓存计算结果、数据库查询或其他处理结果，能显著减轻服务器负担，提高处理效率。
- **缺点**：服务器端缓存需要内存或磁盘空间来存储缓存数据，且如果缓存管理不当，也会出现缓存一致性问题。

### **3. HTTP 缓存**

**HTTP 缓存** 是一种标准的 Web 缓存机制，基于 HTTP 协议的 **缓存头部信息** 来控制缓存策略。它能有效减少资源的重复下载，提升 Web 应用性能。

- **存储位置**：HTTP 缓存可以存储在客户端、代理服务器、CDN 缓存等多处。
- **数据更新方式**：HTTP 缓存依赖于以下 HTTP 头部来控制缓存：
    - `Cache-Control`：指定缓存的行为，如最大过期时间 (`max-age`)、是否公开缓存 (`public`)、是否私有缓存 (`private`)。
    - `Expires`：定义缓存的过期时间（使用 UTC 格式的日期）。
    - `ETag`：服务器返回一个唯一的标识符，客户端可以使用该标识符与服务器进行比对，判断资源是否发生变化。
    - `Last-Modified`：标记资源的最后修改时间，客户端可以基于此时间判断资源是否更新。
    - `Pragma`：用于控制缓存，特别是在 HTTP/1.0 中使用。
- **优点**：通过控制缓存的有效期、刷新策略等，HTTP 缓存能减少数据传输，提升页面加载速度。
- **缺点**：HTTP 缓存机制依赖于服务器和客户端的配合，若配置不当，可能导致缓存数据过时或缓存不生效。

### **4. 浏览器缓存**

**浏览器缓存** 是浏览器实现的客户端缓存，能够缓存从 Web 服务器获取的资源，如 HTML 文件、CSS、JavaScript、图片等。当用户再次访问相同网站时，浏览器可以直接从缓存中加载资源，而不需要再次发送 HTTP 请求。

- **存储位置**：浏览器的本地存储，通常包括 **内存缓存** 和 **硬盘缓存**（如浏览器的缓存文件夹）。
- **数据更新方式**：浏览器缓存通过 HTTP 响应头中的缓存控制字段（如 `Cache-Control`、`Expires`、`ETag` 等）来管理缓存的有效期。如果资源没有过期，浏览器会直接加载缓存。如果资源过期，浏览器会发起请求并检查服务器上的资源是否更新。
- **优点**：显著提高页面加载速度，减少不必要的网络流量和延迟。特别适用于静态资源（如图片、字体、视频、样式表等）的缓存。
- **缺点**：缓存过时或缓存策略不当可能会导致用户无法获取到最新的资源。浏览器需要处理缓存清理和更新。

### **各自的特点总结**

| 缓存类型        | 存储位置           | 数据更新方式                                     | 优点              | 缺点               |
| ----------- | -------------- | ------------------------------------------ | --------------- | ---------------- |
| **客户端缓存**   | 客户端设备（硬盘或内存）   | 基于过期时间或验证机制（如 ETag）                        | 提高加载速度，减少带宽消耗   | 数据可能过时，需要有效的更新策略 |
| **服务器端缓存**  | 服务器（内存或磁盘）     | 基于过期时间或请求频率                                | 减少服务器负担，提升效率    | 占用内存或磁盘空间，需要缓存策略 |
| **HTTP 缓存** | 客户端、代理服务器、CDN等 | 基于 HTTP 头部控制（如 Cache-Control、Expires）      | 减少数据传输，提升页面加载速度 | 配置不当可能导致过时缓存问题   |
| **浏览器缓存**   | 浏览器本地存储        | 基于 HTTP 头部控制（如 Cache-Control、Expires、ETag） | 提升页面加载速度，减少流量   | 可能导致资源过时，需要缓存更新  |

### **总结**

缓存机制通过不同的方式减少冗余的数据请求，优化网络传输性能，提升 Web 应用的响应速度。每种缓存都有其适用的场景和特点，通常需要合理配置和配合使用以获得最佳效果。客户端缓存和浏览器缓存通常是前端缓存，减轻了服务器的负担；而服务器端缓存则主要用于减轻数据库负担，提高计算和数据处理效率。HTTP 缓存作为一种标准机制，通过合理的缓存控制头部配置，可以极大地提高 Web 性能。

## 5.HTTP请求从浏览器发出的整个流程
### **1. 用户输入 URL**

用户在浏览器的地址栏中输入一个 URL（统一资源定位符），比如`http://www.example.com/index.html`。浏览器需要将这个 URL 解析成可以发起请求的地址，并根据 URL 的协议部分（http 或 https）选择适当的方式进行请求。

### **2. URL 解析**

浏览器会解析 URL 中的不同部分：

- **协议**（例如 HTTP 或 HTTPS）
- **主机名**（例如 `www.example.com`）
- **路径**（例如 `/index.html`）
- **查询字符串**（如果有的话，例如 `?id=123`）
- **端口号**（如果有指定，例如 `:8080`）

如果协议是 HTTP 或 HTTPS，浏览器就会开始后续的请求过程。

### **3. DNS 解析**

浏览器需要将域名（例如 `www.example.com`）解析为对应的 IP 地址。这个过程通过 **DNS（域名系统）** 服务器完成，具体步骤包括：

- 浏览器检查本地缓存中是否已经存在该域名的 IP 地址。
- 如果缓存中没有，浏览器会向本地配置的 DNS 服务器发送查询请求。
- 如果 DNS 服务器无法提供答案，它会将请求转发给更高级别的 DNS 服务器，直到找到该域名的 IP 地址。
- 一旦 IP 地址返回，浏览器就会继续发起连接。

### **4. 建立 TCP 连接**

浏览器通过 DNS 解析得到服务器的 IP 地址后，它会与目标服务器建立一个 **TCP 连接**，通常使用 **三次握手**（Three-Way Handshake）过程：

- **客户端发送 SYN 包**：浏览器向服务器发送 SYN（同步）请求，表示希望建立连接。
- **服务器回复 SYN-ACK 包**：服务器收到 SYN 包后，回应一个 SYN-ACK（同步-确认）包，表示同意建立连接。
- **客户端发送 ACK 包**：浏览器再次发送 ACK（确认）包，完成连接的建立。

对于 **HTTPS**，在建立 TCP 连接之后，还会进行 **SSL/TLS 握手**，这涉及到加密协议的协商、证书的验证等步骤。

### **5. 浏览器发起 HTTP 请求**

在 TCP 连接建立后，浏览器通过 **HTTP 请求** 向服务器发送数据，具体的请求包括：

- **请求方法**：常见的有 `GET`、`POST`、`PUT`、`DELETE` 等，指定请求的操作。
- **请求头部（Headers）**：包含了关于客户端的信息，如 `User-Agent`（浏览器类型）、`Accept`（客户端支持的内容类型）、`Cookie`（客户端的 cookies 信息）等。
- **请求体**：对于如 `POST` 或 `PUT` 等方法，可能会附带请求体，包含用户提交的数据（例如表单数据）。

示例的 HTTP 请求：

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
```

### **6. 服务器处理请求并返回响应**

服务器收到 HTTP 请求后，会根据请求的资源路径、方法、参数等进行处理。服务器可能会做如下操作：

- 查询数据库获取数据。
- 调用其他后端服务。
- 读取文件系统中的文件。
- 进行逻辑运算或调用算法处理请求。

处理完成后，服务器会生成一个 **HTTP 响应**，包括以下部分：

- **响应状态码**：如 200（成功）、404（未找到资源）、500（服务器错误）等。
- **响应头部**：如 `Content-Type`（响应内容类型）、`Content-Length`（响应内容长度）、`Set-Cookie`（设置 cookies）等。
- **响应体**：通常是服务器返回的资源数据，如 HTML 内容、JSON 数据、图片文件等。

例如：
```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=UTF-8
Content-Length: 3057

<html>
  <head>
    <title>Example</title>
  </head>
  <body>
    <h1>Welcome to Example.com</h1>
  </body>
</html>
```

### **7. 浏览器接收响应并渲染页面**

浏览器接收到服务器的响应后，会对其进行解析、渲染。这个过程包括：

- **解析 HTML**：浏览器解析响应中的 HTML 内容，构建 DOM 树。
- **加载外部资源**：如果 HTML 中包含外部资源（如 CSS 文件、JavaScript 文件、图片等），浏览器会发起新的请求来获取这些资源。
- **渲染页面**：浏览器根据 DOM 树、CSS 样式表、以及 JavaScript 执行结果渲染最终的页面显示。

### **8. 关闭 TCP 连接**

当页面渲染完成后，HTTP/1.1 默认会在请求完成后保持 TCP 连接一段时间，等待可能的后续请求（保持连接）。如果没有后续请求，浏览器会关闭连接。这个过程称为 **四次挥手**（Four-Way Handshake）。

对于 **HTTP/2** 或 **HTTP/3**，连接管理更加高效，可以复用连接进行多个请求。

### **总结**

浏览器发起 HTTP 请求的整个流程大致如下：

1. **用户输入 URL**。
2. **URL 解析**，提取协议、主机、路径等信息。
3. **DNS 解析**，将域名转换为 IP 地址。
4. **建立 TCP 连接**，进行三次握手。
5. **发起 HTTP 请求**，包括请求头和请求体。
6. **服务器处理请求并返回响应**。
7. **浏览器接收响应并渲染页面**，加载外部资源。
8. **关闭 TCP 连接**，进行四次挥手。

## HTTPS非对称加密的过程

HTTPS（**Hypertext Transfer Protocol Secure**）使用 **SSL/TLS** 协议来实现数据的加密传输，其核心依赖的是 **非对称加密** 和 **对称加密** 的结合。以下是 HTTPS 中非对称加密的详细过程：

---

### **1. 客户端发起 HTTPS 请求**

- 浏览器（客户端）向服务器发起 **HTTPS 请求**，请求建立安全连接（通常是通过端口 443）。

---

### **2. 服务器返回 SSL/TLS 证书**

- 服务器将自己的 **SSL/TLS 证书** 返回给客户端。证书通常由受信任的 **CA（Certificate Authority）** 签发，并包含以下信息：
    - **公钥（Public Key）**
    - 服务器域名
    - 证书颁发机构（CA）的信息
    - 证书有效期等

---

### **3. 客户端验证证书的合法性**

- 客户端使用预装的 **CA 根证书** 验证服务器提供的 SSL/TLS 证书：
    - **检查证书有效期、域名是否匹配、是否被吊销等。**
    - 如果证书不可信（例如自签名证书），浏览器会提示用户安全风险。

---

### **4. 客户端生成对称密钥（非对称加密过程）**

- 客户端生成一个 **随机对称密钥（Session Key）**，用于后续数据传输的对称加密。
- 使用服务器提供的 **公钥（Public Key）** 对这个随机生成的 **对称密钥** 进行 **非对称加密**，然后发送给服务器。
    - **非对称加密特点：**
        - **公钥加密，私钥解密**
        - 只有服务器的私钥才能解密客户端发送的密钥。

---

### **5. 服务器使用私钥解密对称密钥**

- 服务器使用自己的 **私钥（Private Key）** 解密客户端发送的加密对称密钥，成功获得 **Session Key**。
    - 至此，客户端和服务器都拥有相同的 **Session Key**，可以开始使用对称加密进行安全通信。

---

### **6. 双方使用对称加密进行数据传输**

- 后续的数据传输使用 **对称加密算法**（如 **AES**）进行加密和解密。
    - **对称加密**相较于非对称加密更快，适合大规模数据传输。

---

### **7. 数据完整性校验**

- **消息摘要算法**（如 **SHA-256**）用于生成数据摘要，以确保数据在传输过程中未被篡改。
- **TLS** 协议中使用 **MAC（Message Authentication Code）** 来校验数据完整性。

---

### **非对称加密在 HTTPS 中的作用**

1. **确保密钥交换的安全性**：即使数据被截获，没有服务器的私钥也无法解密对称密钥。
2. **验证服务器身份**：通过 CA 签发的证书，确保客户端连接的是合法服务器。

---

### **简化版流程图**

1. **客户端 → 服务器**：发起 HTTPS 请求
2. **服务器 → 客户端**：发送 SSL/TLS 证书（包含公钥）
3. **客户端**：验证证书 → 生成对称密钥 → 用公钥加密密钥并发送
4. **服务器**：用私钥解密密钥
5. **双方**：使用对称加密进行通信（使用协商的对称密钥）

---

### **非对称加密算法**

- **RSA**（最常用，公钥私钥加密解密）
- **ECC**（椭圆曲线加密，性能更优）

---

### **对称加密算法**

- **AES**（高级加密标准）
- **ChaCha20**（轻量高效）






