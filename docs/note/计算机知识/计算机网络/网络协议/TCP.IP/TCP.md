# [理解TCP握手](https://juejin.cn/post/6844904070000410631?searchId=2025020617532906C6E83855F4D3E1A0E8)

### TCP 协议简述

TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。

无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过**三次握手**进行初始化的。  
同时由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是**全双工模式**，所以需要**四次挥手**关闭连接。

### TCP包首部

网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。

所以我们在学习TCP协议之前，首先要知道TCP在网络传输中处于哪个位置，以及它的协议的规范，下面我们就看看TCP首部的网络传输起到的作用：

![网络数据传输过程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b9013236e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp "网络数据传输过程")

网络数据传输过程

下面的图是TCP头部的规范定义，它定义了TCP协议如何读取和解析数据：  

![TCP头部](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b90391b6e~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp "TCP头部")

TCP头部

TCP首部承载这TCP协议需要的各项信息，下面我们来分析一下：

- **TCP端口号**  
    TCP的连接是需要四个要素确定唯一一个连接：  
    **（源IP，源端口号）+ （目地IP，目的端口号）**  
    所以TCP首部预留了两个16位作为端口号的存储，而IP地址由上一层IP协议负责传递  
    源端口号和目地端口各占16位两个字节，也就是端口的范围是2^16=65535  
    另外1024以下是系统保留的，从1024-65535是用户使用的端口范围
    
- **TCP的序号和确认号**：  
    **32位序号 seq**：Sequence number 缩写seq ，TCP通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据**有序**，比如现在序列号为1000，发送了1000，下一个序列号就是2000。  
    **32位确认号 ack**：Acknowledge number 缩写ack，TCP对上一次seq序号做出的确认号，用来响应TCP报文段，给收到的TCP报文段的序号seq加1。
    
- **TCP的标志位**  
    每个TCP段都有一个目的，这是借助于TCP标志位选项来确定的，允许发送方或接收方指定哪些标志应该被使用，以便段被另一端正确处理。  
    用的最广泛的标志是 **SYN**，**ACK** 和 **FIN**，用于建立连接，确认成功的段传输，最后终止连接。
    

1. **SYN**：简写为`S`，同步标志位，用于建立会话连接，同步序列号；
2. **ACK**： 简写为`.`，确认标志位，对已接收的数据包进行确认；
3. **FIN**： 简写为`F`，完成标志位，表示我已经没有数据要发送了，即将关闭连接；
4. PSH：简写为`P`，推送标志位，表示该数据包被对方接收后应立即交给上层应用，而不在缓冲区排队；
5. RST：简写为`R`，重置标志位，用于连接复位、拒绝错误和非法的数据包；
6. URG：简写为`U`，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；

### TCP 三次握手建立连接

所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个报文。

三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时。将触发三次握手。

三次握手过程的示意图如下：  

![三次握手建立连接](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b92f7503f~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp "三次握手建立连接")

三次握手建立连接

- **第一次握手**：  
    客户端将TCP报文**标志位SYN置为1**，随机产生一个序号值seq=J，保存在TCP首部的序列号(Sequence Number)字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。
    
- **第二次握手**：  
    服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将TCP报文**标志位SYN和ACK都置为1**，ack=J+1，随机产生一个序号值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。
    
- **第三次握手**：  
    客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。
    

注意:我们上面写的ack和ACK，不是同一个概念：

- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，ack=seq+1。
- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。

下面我自己做实验，开一个HTTP服务，监听80端口，然后使用Tcpdump命令抓包，看一下TCP三次握手的过程：


```
sudo tcpdump -n -t -S -i enp0s3  port 80       

第一次握手，标志位Flags=S   IP 10.0.2.2.51323 > 10.0.2.15.80: Flags [S], seq 84689409, win 65535, options [mss 1460], length 0   

第二次握手，标志位Flags=[S.]   IP 10.0.2.15.80 > 10.0.2.2.51323: Flags [S.], seq 1893430205, ack 84689410, win 64240, options [mss 1460], length 0   

第三次握手，标志位Flags=[.]   IP 10.0.2.2.51323 > 10.0.2.15.80: Flags [.], ack 1893430206, win 65535, length 0   

建立连接后，客户端发送http请求    IP 10.0.2.2.51321 > 10.0.2.15.80: Flags [P.], seq 1:753, ack 1, win 65535, length 752: HTTP: GET / HTTP/1.1
```

> tcpdump命令解析一下：  
> -i : 指定抓包的网卡是enp0s3  
> -n: 把域名转成IP显示  
> -t: 不显示时间  
> -S: 序列号使用绝对数值，不指定-S的话，序列号会使用相对的数值  
> port: 指定监听端口是80  
> host:指定监听的主机名

我们看下实战中TCP的三次握手过程：

- 第一次握手，客户端51323端口号向服务器端80号端口发起连接，此时标志位flags=S，即SYN=1标志，表示向服务端发起连接的请求，同时生成序列号seq=84689409
- 第二次握手，服务端标志位flags=[S.]，即SYN+ACK标志位设置为1，表示对上一个请求连接的报文进行确认，同时设置ack=seq+1=184689410，生成序列号seq=1893430205
- 第三次握手，客户端对服务端的响应进行确认，所以此时标志位是[.]即ACK=1，同时返回对上一个报文的seq的确认号，ack=1893430206

至此，三次握手完成，一个TCP连接建立完成，接下来就是双端传输数据了

#### 为什么需要三次握手？

我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。

本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。

所以，采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

TCP 三次握手跟现实生活中的人与人打电话是很类似的：

> 三次握手：  
> “喂，你听得到吗？”  
> “我听得到呀，你听得到我吗？”  
> “我能听到你，今天 balabala……”

经过三次的互相确认，大家就会认为对方对听的到自己说话，并且愿意下一步沟通，否则，对话就不一定能正常下去了。

### TCP 四次挥手关闭连接

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。  
由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

四次挥手过程的示意图如下：  

![四次挥手关闭连接](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/2/22/1706c89b93024c48~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp "四次挥手关闭连接")

四次挥手关闭连接

挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：

- **第一次挥手**： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入`FIN_WAIT_1`状态，这表示Client端没有数据要发送给Server端了。
- **第二次分手**：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入`FIN_WAIT_2`状态，Server端告诉Client端，我确认并同意你的关闭请求。
- **第三次分手**： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入`LAST_ACK`状态。
- **第四次分手** ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入`TIME_WAIT`状态。Server端收到Client端的ACK报文段以后，就关闭连接。此时，Client端等待**2MSL**的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。

#### 为什么连接的时候是三次握手，关闭的时候却是四次握手？

建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送**SYN+ACK**报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。

由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是**全双工模式**。  
这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。  
当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。

#### 为什么要等待2MSL？

**MSL**：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。  
有以下两个原因：

- **第一点：保证TCP协议的全双工连接能够可靠关闭**：  
    由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN的收，能够保证对方收到ACK，最后正确关闭连接。
- **第二点：保证这次连接的重复数据段从网络中消失**  
    如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱。所以TCP连接需要在TIME_WAIT状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。

### 最后

文章如果对你有收获，可以收藏转发！另外可以关注我公众号**「码农富哥」**，我会持续输出数据库，架构，计算机基础的 **原创** 文章

  

作者：公众号_码农富哥  
链接：https://juejin.cn/post/6844904070000410631  
来源：稀土掘金  
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
# [TCP握手面经](https://juejin.cn/post/6976121003847974949?from=search-suggest)
三次握手和四次挥手是各个公司常见的考点，也具有一定的水平区分度，也被一些面试官作为热身题。很多小伙伴说这个问题刚开始回答的挺好，但是后面越回答越冒冷汗，最后就歇菜了。

见过比较典型的面试场景是这样的:

> 面试官：请介绍下三次握手  
> 求职者：第一次握手就是客户端给服务器端发送一个报文，第二次就是服务器收到报文之后，会应答一个报文给客户端，第三次握手就是客户端收到报文后再给服务器发送一个报文，三次握手就成功了。  
> 面试官：然后呢？  
> 求职者：这就是三次握手的过程，很简单的。  
> 面试官：。。。。。。  
> （**番外篇：一首凉凉送给你**）

记住猿人谷一句话：**面试时越简单的问题，一般就是隐藏着比较大的坑，一般都是需要将问题扩展的**。上面求职者的回答不对吗？当然对，但距离面试官的期望可能还有点距离。

希望大家能带着如下问题进行阅读，收获会更大。

1. 请画出三次握手和四次挥手的示意图
2. 为什么连接的时候是三次握手？
3. 什么是半连接队列？
4. ISN(Initial Sequence Number)是固定的吗？
5. 三次握手过程中可以携带数据吗？
6. 如果第三次握手丢失了，客户端服务端会如何处理？
7. SYN攻击是什么？
8. 挥手为什么需要四次？
9. 四次挥手释放连接时，等待2MSL的意义?

![三次握手和四次挥手.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5751d6e7935847deb6a009c2884dba4a~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

## [](https://link.juejin.cn?target=)1. 三次握手

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换`TCP窗口大小`信息。

刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。  
进行三次握手：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 `SYN_SENT` 状态。
    
    首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
    
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 `SYN_RCVD` 的状态。
    
    在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
    
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 `ESTABLISHED` 状态。服务器收到 ACK 报文之后，也处于 `ESTABLISHED` 状态，此时，双方已建立起了连接。
    
    确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。
    

发送第一个SYN的一端将执行主动打开（active open），接收这个SYN并发回下一个SYN的另一端执行被动打开（passive open）。

在socket编程中，客户端执行connect()时，将触发三次握手。

![三次握手.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cdf08cf85d434853a2d84779a57fb281~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

### [](https://link.juejin.cn?target=)1.1 为什么需要三次握手，两次不行吗？

弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

- 第一次握手：客户端发送网络包，服务端收到了。  
    这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了。  
    这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
- 第三次握手：客户端发包，服务端收到了。  
    这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。

试想如果是用两次握手，则会出现下面这种情况：

> 如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在**某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端**，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。

### [](https://link.juejin.cn?target=)1.2 什么是半连接队列？

服务器第一次收到客户端的 SYN 之后，就会处于 SYN_RCVD 状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个**队列**里，我们把这种队列称之为**半连接队列**。

当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。

这里在补充一点关于**SYN-ACK 重传次数**的问题：  
服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。  
注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…

### [](https://link.juejin.cn?target=)1.3 ISN(Initial Sequence Number)是固定的吗？

当一端为建立连接而发送它的SYN时，它为连接选择一个初始序号。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

**三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。**

### [](https://link.juejin.cn?target=)1.4 三次握手过程中可以携带数据吗？

其实第三次握手的时候，是可以携带数据的。但是，**第一次、第二次握手不可以携带数据**

为什么这样呢?大家可以想一个问题，假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据。因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。

也就是说，**第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据也没啥毛病。**

### [](https://link.juejin.cn?target=)1.5 SYN攻击是什么？

**服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的**，所以服务器容易受到SYN洪泛攻击。SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。

检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。

css

 代码解读

复制代码

`netstat -n -p TCP | grep SYN_RECV     1`

常见的防御 SYN 攻击的方法有如下几种：

- 缩短超时（SYN Timeout）时间
- 增加最大半连接数
- 过滤网关防护
- SYN cookies技术

## [](https://link.juejin.cn?target=)2. 四次挥手

建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的**半关闭**（half-close）造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

TCP 连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务端均可主动发起挥手动作。

刚开始双方都处于`ESTABLISHED` 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 `FIN_WAIT1` 状态。  
    即发出**连接释放报文段**（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 `CLOSE_WAIT` 状态。  
    即服务端收到连接释放报文段后即发出**确认报文段**（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态。  
    即服务端没有要向客户端发出的数据，服务端发出**连接释放报文段**（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 `TIME_WAIT` 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 `CLOSED` 状态。  
    即客户端收到服务端的连接释放报文段后，对此发出**确认报文段**（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。

收到一个FIN只意味着在这一方向上没有数据流动。**客户端执行主动关闭并进入TIME_WAIT是正常的，服务端通常执行被动关闭，不会进入TIME_WAIT状态。**

在socket编程中，任何一方执行close()操作即可产生挥手操作。  
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/008976cc4bcf4be4b11d03c5540cc038~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

### [](https://link.juejin.cn?target=)2.1 挥手为什么需要四次？

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

### [](https://link.juejin.cn?target=)2.2 2MSL等待状态

TIME_WAIT状态也成为2MSL等待状态。每个具体TCP实现必须选择一个报文段最大生存时间MSL（Maximum Segment Lifetime），它是任何报文段被丢弃前在网络内的最长时间。这个时间是有限的，因为TCP报文段以IP数据报在网络内传输，而IP数据报则有限制其生存时间的TTL字段。

对一个具体实现所给定的MSL值，处理的原则是：当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。

这种2MSL等待的另一个结果是这个TCP连接在2MSL等待期间，定义这个连接的插口（客户的IP地址和端口号，服务器的IP地址和端口号）不能再被使用。这个连接只能在2MSL结束后才能再被使用。

### [](https://link.juejin.cn?target=)2.3 四次挥手释放连接时，等待2MSL的意义?

> **MSL**是Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。

为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间`等待计时器`。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

#### [](https://link.juejin.cn?target=)两个理由：

10. **保证客户端发送的最后一个ACK报文段能够到达服务端**。
    
    这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，服务端超时重传FIN+ACK报文段，而客户端能在2MSL时间内收到这个重传的FIN+ACK报文段，接着客户端重传一次确认，重新启动2MSL计时器，最后客户端和服务端都进入到CLOSED状态，若客户端在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到服务端重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则服务端无法正常进入到CLOSED状态。
    
11. **防止“已失效的连接请求报文段”出现在本连接中**。
    
    客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。
    

### [](https://link.juejin.cn?target=)2.4 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

理论上，四个报文都发送完毕，就可以直接进入CLOSE状态了，但是可能网络是不可靠的，有可能最后一个ACK丢失。所以**TIME_WAIT状态就是用来重发可能丢失的ACK报文**。

## [](https://link.juejin.cn?target=)3. 总结

《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。

![TCP状态变迁图.jpg](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5094a43c10a4ff6a4c71894064d266c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp)

**以后面试官再问你三次握手和四次挥手，直接把这一篇文章丢给他就可以了，他想问的都在这里。**

**参考：《TCP/IP详解 卷1:协议》**

## TCP三次握手四次挥手
下面我详细讲解一下 TCP 连接建立时的三次握手（Three-way Handshake）和断开连接时的四次挥手（Four-way Handshake）。

---

### 一、三次握手（建立连接）

TCP 采用三次握手来建立一个可靠的全双工通信连接，主要目的是让双方都确认对方的接收能力、初始化序列号，并同步双方的初始序列号。具体过程如下：

1. **第一次握手（SYN）：**
    
    - **客户端**向服务器发起连接请求，发送一个带有 SYN（同步）标志的数据包。
    - 该数据包中包含客户端初始的序列号（Sequence Number），比如记作 `x`。
    - 此时客户端进入 **SYN-SENT** 状态。
2. **第二次握手（SYN-ACK）：**
    
    - **服务器**收到客户端的 SYN 数据包后，如果同意建立连接，就会回复一个数据包。
    - 这个数据包同时带有 SYN 和 ACK（确认）标志。
    - 服务器选择自己的初始序列号（记作 `y`），并在 ACK 字段中对客户端的序列号 `x` 进行确认（即发送 `x+1`）。
    - 服务器进入 **SYN-RECEIVED** 状态。
3. **第三次握手（ACK）：**
    
    - **客户端**收到服务器的 SYN-ACK 数据包后，再发送一个 ACK 数据包给服务器，
    - 在该数据包中，客户端将确认服务器的序列号 `y`（即发送 `y+1`）。
    - 发送完毕后，客户端进入 **ESTABLISHED（已连接）** 状态。
    - 服务器收到这个 ACK 后，也进入 **ESTABLISHED** 状态，从而建立起双向通信的连接。

通过这三次交互，双方确认了连接双方的发送和接收能力，并交换了初始序列号，从而确保数据传输的可靠性和顺序性。

---

### 二、四次挥手（断开连接）

TCP 连接断开时采用四次挥手的过程，这是因为 TCP 是全双工的，每个方向的数据传输都需要单独关闭。具体过程如下：

4. **第一次挥手（FIN）：**
    
    - **主动关闭端（比如客户端）** 当不再需要发送数据时，会向对方发送一个带有 FIN（结束）标志的数据包，表示数据发送完毕。
    - 此时客户端进入 **FIN-WAIT-1** 状态。
5. **第二次挥手（ACK）：**
    
    - **被动关闭端（比如服务器）** 收到 FIN 后，立即发送一个 ACK 数据包来确认，表示知道对方已经没有数据发送了。
    - 服务器此时进入 **CLOSE-WAIT** 状态，而客户端收到 ACK 后，进入 **FIN-WAIT-2** 状态。
6. **第三次挥手（FIN）：**
    
    - 当服务器也完成数据发送后，会向客户端发送一个带有 FIN 标志的数据包，表示服务器端也没有数据需要发送。
    - 这时服务器进入 **LAST-ACK** 状态。
7. **第四次挥手（ACK）：**
    
    - **主动关闭端（客户端）** 收到服务器的 FIN 后，发送一个 ACK 数据包来确认，
    - 发送完 ACK 后，客户端进入 **TIME-WAIT** 状态，等待一段时间（通常为 2 倍的最大报文段寿命，MSL）以确保服务器收到了最后的 ACK。
    - 服务器收到这个 ACK 后，进入 **CLOSED** 状态，完成断开。

#### 为什么需要四次挥手？

- **全双工通信：** TCP 的连接是全双工的，即数据传输是双向独立的。因此，每个方向都需要单独关闭。
- **确保数据传输完整：** 在断开连接前，双方需要确保所有数据已经传输完毕，尤其是在关闭连接时可能还存在未确认的数据包。
- **TIME-WAIT 状态：** 主动关闭端进入 TIME-WAIT 状态是为了确保最后一个 ACK 能够被服务器接收，同时处理可能的重复分组，避免混淆下一次的连接。

#### 名词解释

1. **SYN（Synchronize）**
    
    - **作用**：在 TCP 协议中，SYN 标志位用于发起连接。
    - **具体含义**：当一个主机（比如客户端）希望与另一台主机（比如服务器）建立 TCP 连接时，会发送一个带有 SYN 标志的数据包，这个包包含了客户端选择的初始序列号。
    - **背景**：这是三次握手过程中的第一步，表明“我想开始通信”。
2. **ACK（Acknowledgment）**
    
    - **作用**：ACK 标志位用于确认接收到数据。
    - **具体含义**：在 TCP 通信中，每当一方接收到数据包时，通常会发送一个 ACK 数据包，告知发送方“我已经收到你的数据”。
    - **背景**：ACK 是确保数据传输可靠性的重要机制，出现在连接建立、数据传输、连接关闭等各个阶段。
3. **ISN（Initial Sequence Number）**
    
    - **作用**：ISN 是 TCP 连接建立时用于初始化序列号的数值。
    - **具体含义**：在建立连接的过程中，双方各自选择一个初始序列号（ISN），用于标记后续数据的顺序。
    - **背景**：通过 ISN，接收方可以确认收到的数据包是否按顺序到达，防止数据重传或数据丢失的情况。每次建立新连接时，ISN 通常会随机选择一个数值以增强安全性和可靠性。
4. **FIN（Finish）**
    
    - **作用**：FIN 标志位用于关闭连接，表明发送方的数据发送已经结束。
    - **具体含义**：当一方不再需要发送数据时，会发送一个带有 FIN 标志的数据包，通知对方“我这边的数据已经全部发送完毕，请关闭连接”。
    - **背景**：在 TCP 的四次挥手中，FIN 起到了启动关闭通信的一方与等待关闭的另一方之间的协调作用，确保双方都能有序地终止数据传输。
5. **全双工（Full Duplex）**
    
    - **作用**：全双工通信指双方可以同时进行数据传输，不需要像半双工那样先发送后接收或先接收后发送。
    - **具体含义**：在全双工模式下，通信的双方可以同时发送和接收数据，彼此互不干扰，从而实现双向并行通信。
    - **背景**：TCP 协议提供的通信就是全双工的，意味着在一个已建立的连接中，双方都可以同时发送数据，而不必等待对方停止发送，从而提高了通信效率。

---

这些术语在 TCP 协议中都有着各自重要的角色，从建立连接、数据传输到连接终止，共同保证了网络通信的可靠性和高效性。希望这些解释能帮助你更好地理解相关概念！